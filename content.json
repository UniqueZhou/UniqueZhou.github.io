{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"Unique","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"RN中没有固定定位怎么办？","slug":"RN中没有固定定位怎么办？","date":"2019-08-07T04:04:01.000Z","updated":"2019-08-07T04:13:42.461Z","comments":true,"path":"passages/RN中没有固定定位怎么办？/","link":"","permalink":"http://yoursite.com/passages/RN中没有固定定位怎么办？/","excerpt":"","text":"如上图的底部新增按钮，要是放在web里那是相当简单，直接是用固定定位就行，但是在RN里是没有固定定位。 怎么解决? 方案一 绝对定位采用绝对定位，相对于最外层的定位在底部位置。 在部分安卓机上有问题，动态计算的高度，定位底部的高度有问题，导致底部按钮定位脱离了视野 方案二 flex布局如上图，头部导航 是固定的， 剩下的就是 组件（红色方框区域） 设置属性 flex:1 使它撑满剩余空间，这时候可以设置它为相对定位，然后底部那个按钮绝对定位，这样可行， 但是我们可以用flex一层一层撑开。 按钮底部空白的位置，不是定位出来的，其实是适应iphoneX组件的空间，忽略。 接下来只要把内部划成三块就行：tab导航 列表内容 底部按钮 。 列表内容和底部导航是由一个VIew 包着 和tab 导航同一层级的。所以这个View 设置flex:1. 到了最后一层，就是设置列表内容 flex:1 ， 底部按钮固定高度。这样根据flex布局的属性，底部按钮就被挤在 最下面这个位置了。 这个方法相对于直接用一层定位来，多了几层flex:1，但是省去了计算高度的工作，不存在安卓的兼容性，免去了样式爆炸的烦恼。 总结：最核心就是一点，一层层设置flex：1,把固定高度的挤在固定的地方就行。","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"浅谈BFC原理及作用","slug":"浅谈BFC原理及作用","date":"2019-08-06T05:19:20.000Z","updated":"2019-08-06T05:21:31.540Z","comments":true,"path":"passages/浅谈BFC原理及作用/","link":"","permalink":"http://yoursite.com/passages/浅谈BFC原理及作用/","excerpt":"","text":"一. BFC的概念BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述布局模式的流动模型。是W3C CSS2.1规范中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的的一些特性。 通俗一点来讲，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 二.BFC的形成条件只要元素满足下面任一条件即可触发BFC特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 三.BFC常见的作用1.组织外边距重叠例：margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。 可以用overflow：hidden产生bfc来解决。 123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; ​ 因为两个div元素都处于同一个BFC容器下（这里指body元素），所以第一个div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 123456789.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; ​ 2.包含浮动元素 例：高度塌陷问题，在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合，这时就可以用BFC来清除浮动了。 123&lt;div style=\"border: 1px solid #000;\"&gt; &lt;div style=\"width: 100px;height: 100px;background: grey;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度。如果触发容器的BFC，那么容器将会包裹浮动元素。 ​ 3、阻止元素被浮动元素覆盖 例：div浮动兄弟这该问题：由于左侧块级元素发生了浮动，所以和右侧未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。可以给右侧元素添加 overflow: hidden，触发BFC来解决遮挡问题。 我是一个左浮动的元素我是一个没有设置浮动,也没有触发 BFC 元素, width: 200px; height:200px; background: grey; 1这时候其实第二个元素有部分被浮动元素所覆盖，但是文本信息不会被浮动元素所覆盖，如果想避免元素被覆盖，可触发第二个元素的BFC特性，在第二个元素中加入overflow：hidden，就会变成： 我是一个左浮动的元素我是一个没有设置浮动,也没有触发 BFC 元素, width: 200px; height:200px; background: grey; ​ 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"media与screen的自适应网页布局","slug":"media与screen的自适应网页布局","date":"2019-08-06T05:06:24.000Z","updated":"2019-08-06T05:16:40.022Z","comments":true,"path":"passages/media与screen的自适应网页布局/","link":"","permalink":"http://yoursite.com/passages/media与screen的自适应网页布局/","excerpt":"","text":"1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 height = device-height：高度等于当前设备的高度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果： 1234&lt;!--[if lt IE 9]&gt;&lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;&lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8: 为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; （如果想使用固定的IE版本，可写成： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=EmulateIE9\"&gt; ） 除此之外，还有一个更好的写法： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge，chrome=1\"&gt; 怎么这段代码后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。 CSS3 Media写法我们先来看下下面这段代码，估计很多人在响应式的网站CSS很经常看到类似下面的这段代码： 12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS. 应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写： 12345@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; CSS2 Media用法其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"style.css\"&gt; 上面其实是CSS2实现的衬线用法，那CSS2的media难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (orientation:portrait)\" href=\"style.css\"&gt; 我们把第一段的代码也用CSS2来实现，让它一样可以让页面宽度小于960的执行指定的样式文件： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-width:960px)\" href=\"style.css\"&gt; 既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 回归CSS3 Media上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码： 12345@media screen and (max-device-width:960px)&#123; body&#123; background:red; &#125;&#125; 然后就是当浏览器尺寸大于960px时候的代码了： 12345@media screen and (min-width:960px)&#123; body&#123; background:orange; &#125;&#125; 我们还可以混合使用上面的用法： 12345@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123; background:yellow; &#125;&#125; 上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。 Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格的还是位图设备。 注意下顺序，如果你把@media (min-width: 768px)写在了下面那么很悲剧， @media (min-width: 1200){ //&gt;=1200的设备 } @media (min-width: 992px){ //&gt;=992的设备 } @media (min-width: 768px){ //&gt;=768的设备 } 因为如果是1440,由于1440&gt;768那么你的1200就会失效。 所以我们用min-width时，小的放上面大的在下面，同理如果是用max-width那么就是大的在上面，小的在下面 @media (max-width: 1199){ //&lt;=1199的设备 } @media (max-width: 991px){ //&lt;=991的设备 } @media (max-width: 767px){ //&lt;=768的设备 } 1280分辨率以上（大于1200px） 123@media screen and (min-width:1200px)&#123; #page&#123; width: 1100px; &#125;#content,.div1&#123;width: 730px;&#125;#secondary&#123;width:310px&#125;&#125; 1100分辨率（大于960px，小于1199px） 123@media screen and (min-width: 960px) and (max-width: 1199px) &#123; #page&#123; width: 960px; &#125;#content,.div1&#123;width: 650px;&#125;#secondary&#123;width:250px&#125;select&#123;max-width:200px&#125;&#125; 880分辨率（大于768px，小于959px） 123@media screen and (min-width: 768px) and (max-width: 959px) &#123; #page&#123; width: 900px; &#125;#content,.div1&#123;width: 620px;&#125;#secondary&#123;width:220px&#125;select&#123;max-width:180px&#125;&#125; 720分辨率（大于480px，小于767px） 123@media only screen and (min-width: 480px) and (max-width: 767px)&#123; #page&#123; width: 450px; &#125;#content,.div1&#123;width: 420px;position: relative; &#125;#secondary&#123;display:none&#125;#access&#123;width: 450px; &#125;#access a &#123;padding-right:5px&#125;#access a img&#123;display:none&#125;#rss&#123;display:none&#125;#branding #s&#123;display:none&#125;&#125; 440分辨率以下（小于479px） 123@media only screen and (max-width: 479px) &#123; #page&#123; width: 300px; &#125;#content,.div1&#123;width: 300px;&#125;#secondary&#123;display:none&#125;#access&#123;width: 330px;&#125; #access a &#123;padding-right:10px;padding-left:10px&#125;#access a img&#123;display:none&#125;#rss&#123;display:none&#125;#branding #s&#123;display:none&#125;#access ul ul a&#123;width:100px&#125;&#125; 12345/* 竖屏 */@media screen and (orientation: portrait) and (max-width: 720px) &#123; 对应样式 &#125;/* 横屏 */@media screen and (orientation: landscape) &#123; 对应样式 &#125; 上面的代码中用到了screen ，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时。 PC端按屏幕宽度大小排序 分辨率 比例 | 设备尺寸 1024500 （8.9寸）1024768 （比例4：3 | 10.4寸、12.1寸、14.1寸、15寸; ）1280800（16：10 |15.4寸）12801024(比例：5：4 | 14.1寸、15.0寸)1280854(比例：15：10 | 15.2）1366768 (比例：16：9 | 不常见）1440900 （16：10 17寸 仅苹果用）14401050（比例：5：4 | 14.1寸、15.0寸）16001024（14：9 不常见）16001200 （4：3 | 15、16.1）16801050（16：10 | 15.4寸、20.0寸）19201200 (23寸） 通过上面的电脑屏蔽及尺寸的例表上我们得到了几个宽度1024 1280 1366 1440 1680 1920 CSS代码 @media (min-width: 1024px){ body{font-size: 18px}} /&gt;=1024的设备/@media (min-width: 1100px) { body{font-size: 20px}} /&gt;=1024的设备/@media (min-width: 1280px) { body{font-size: 22px;}}@media (min-width: 1366px) { body{font-size: 24px;}}@media (min-width: 1440px) { body{font-size: 25px !important;}}@media (min-width: 1680px) { body{font-size: 28px;}}@media (min-width: 1920px) { body{font-size: 33px;}}","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jQuery复习","slug":"jQuery复习","date":"2019-05-16T05:24:23.000Z","updated":"2019-05-16T05:28:15.229Z","comments":true,"path":"passages/jQuery复习/","link":"","permalink":"http://yoursite.com/passages/jQuery复习/","excerpt":"","text":"一.选择器1.1 基本选择器#id id选择器 12&lt;div id=&apos;one&apos;&gt;AAA&lt;/div&gt;$(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;red&quot;); element 标签选择器 123&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;$(\"div\").css(\"background-color\",\"yellow\"); .class 类选择器 12&lt;div class='mini'&gt;AAA&lt;/div&gt;$(\".mini\").css(\"background-color\",\"blue\"); * 所有元素 1234&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;h1&gt;ccc&lt;/h1&gt;$(\"*\").css(\"background-color\",\"green\"); s1,s2,… 多选择器，将多个选择器的结果添加一个数组中 1234&lt;div class='mini'&gt;AAA&lt;/div&gt;&lt;div id='two'&gt;BBB&lt;/div&gt;&lt;span&gt;CCC&lt;/span&gt;$(\"span,#two,.mini\").css(\"background-color\",\"brown\"); 1.2 层级选择器A B ，获得A元素内部所有的B元素 1234&lt;body&gt; &lt;div class='mini'&gt;AAA&lt;/div&gt;&lt;/body&gt;$(\"body div\").css(\"background-color\", \"red\"); A &gt; B ，获得A元素内部所有的B子元素 123456&lt;body&gt; &lt;div&gt;AAA&lt;/div&gt; &lt;div&gt;BBB&lt;/div&gt; &lt;span&gt;CCC&lt;/span&gt;&lt;/body&gt;$(\"body &gt; div\").css(\"background-color\", \"yellow\"); A + B ，获得A元素后面的第一个兄弟B 123&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;$(\"div + div\").css(\"background-color\", \"blue\"); A ~ B ，获得A元素后面的所有的兄弟B 123456&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;BBB&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;div&gt;eee&lt;/div&gt;$(&quot;div ~ span&quot;).css(&quot;background-color&quot;, &quot;green&quot;); A.siblings(“B”)，A的所有是B的兄弟 12345&lt;span&gt;BBB&lt;/span&gt;&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;$(\"div\").siblings(\"span\").css(\"background-color\", \"brown\"); 1.3 基本过滤选择器 过滤选择器都有 : :first 选中第一个元素 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:first\").css(\"background-color\", \"red\"); :last 选中最后一个 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:last\").css(\"background-color\", \"yellow\"); :eq(index) 获得指定索引(从0开始) 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:eq(2)\").css(\"background-color\", \"blue\"); :gt(index) 大于 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:gt(1)\").css(\"background-color\", \"red\"); :lt(index) 小于 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:lt(1)\").css(\"background-color\", \"green\"); :animated 获得所有在动画的元素 1$(\":animated\").css(\"background-color\", \"green\"); :not(selector) 去除所有与给定选择器匹配的元素 1234&lt;div class=\"one\"&gt;AAA&lt;/div&gt;&lt;div class=\"two\"&gt;BBB&lt;/div&gt;&lt;div class=\"three\"&gt;CCC&lt;/div&gt; $(\"div:not('.one')\").css(\"background-color\", \"blue\"); :header 获得所有标题元素 例如：… 1234&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;$(\":header\").css(\"background-color\", \"green\").css(\"font-size\",\"30px\"); :even 偶数，从 0 开始计数 12345&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:even\").css(\"background-color\", \"brown\"); :odd 奇数 12345&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:odd\").css(\"background-color\", \"yellow\"); 1.4 内容过滤选择器 均要加冒号 :empty 当前元素是否为空（是否有标签体–子元素、文本） 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:empty\").css(\"background-color\",\"yellow\"); :has(…) 当前元素，是否含有指定的子元素 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:has('span')\").css(\"background-color\",\"blue\"); :parent 当前元素是否是父元素（自己是否拥有子元素） 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:parent\").css(\"background-color\",\"green\"); :contains( text ) 标签体是否含有指定的文本 1234&lt;div&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div&gt;ddd&lt;/div&gt;$(\"div:contains('d')\").css(\"background-color\",\"red\"); 1.5 可见性过滤选择器:hidden 隐藏。特指 &lt;xxx style=&quot;display:none;&quot;&gt; 或者 &lt;input type=&quot;hidden&quot;&gt; 1234&lt;div style=\"display:none\"&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;input type=\"hidden\"&gt;$(\"div:hidden\").show(1000).css(\"background-color\",\"yellow\"); :visible 可见（默认） 1234&lt;div style=\"display:none\"&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;input type=\"hidden\"&gt;$(\"div:visible\").css(\"background-color\",\"red\"); 1.6 属性选择器[属性名] 获得指定的属性名的元素 1234&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div&gt;ddd&lt;/div&gt;$(\"div[title]\").css(\"background-color\",\"red\"); [属性名=值] 获得属性名 等于 指定值的 的元素 1234&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div title='test'&gt;ddd&lt;/div&gt;$(\"div[title='test']\").css(\"background-color\",\"blue\"); [属性名!=值] 获得属性名 不等于 指定值的 的元素 123&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div title='test'&gt;ddd&lt;/div&gt; $(\"div[title!='test']\").css(\"background-color\",\"yellow\"); [as1][as2][as3]…. 复合选择器，多个条件同时成立。类似 where …and…and 1234&lt;div title='aes' id=\"aaa\"&gt;aaa&lt;/div&gt;&lt;div &gt;bbb&lt;/div&gt;&lt;div title='test' id='ddd'&gt;ddd&lt;/div&gt;$(\"div[id][title*='es']\").css(\"background-color\",\"red\"); [属性名^=值] 获得以属性值 开头 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title^='te']\").css(\"background-color\",\"green\"); [属性名$=值] 获得以属性值 结尾 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title$='est']\").css(\"background-color\",\"brown\"); [属性名*=值] 获得 含有属性值 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title*='es']\").css(\"background-color\",\"yellow\"); 1.7 元素过滤选择器:nth-child(n) 第n个孩子(从1开始) 1234567&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"body :nth-child(2)\").css(\"background-color\",\"yellow\"); :first-child 第一个孩子 12345678910111213&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;//注意空格的区别$(\"div :first-chlid\").css(\"background-color\",\"yellow\");//div里面的元素的第一个$(\"div:first-chlid\").css(\"background-color\",\"yellow\");//div的第一个 :last-child 最后一个孩子 12345678910111213&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;//注意空格的区别$(\"div :last-chlid\").css(\"background-color\",\"yellow\");//div里面的元素的最后一个$(\"div:last-chlid\").css(\"background-color\",\"yellow\");//div的最后一个 :only-child 仅有一个孩子 123456789101112&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"div :last-chlid\").css(\"background-color\",\"yellow\"); 1.8 表单过滤选择器:input 所有的表单元素。&lt;input&gt; / &lt;select&gt; / &lt;textarea&gt; / &lt;button&gt; 12345&lt;input&gt;&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;button&gt;&lt;/button&gt;$(\":input\").css(\"background-color\",\"yellow\"); :text 文本框&lt;input type=&quot;text&quot;&gt; 12&lt;input type=\"text\"&gt;$(\":text\").css(\"background-color\",\"yellow\"); :password 密码框&lt;input type=&quot; password &quot;&gt; 12&lt;input type=\"password\"&gt;$(\":password\").css(\"background-color\",\"yellow\"); :radio 单选&lt;input type=&quot;radio&quot;&gt; 1234567&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;苹果 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;桃子 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;香蕉 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;梨 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;其它 &lt;/label&gt; &lt;input type=\"radio\"&gt;$(\":radio\").css(\"background-color\",\"yellow\"); :checkbox 复选框&lt;input type=&quot;checkbox&quot;&gt; 123456789&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"今日话题\" /&gt;今日话题 &lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"视觉焦点\" /&gt;视觉焦点&lt;/p&gt;&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"财经\" /&gt;财经&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"汽车\" /&gt;汽车&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"科技\" /&gt;科技&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"房产\" /&gt;房产&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"旅游\" /&gt;旅游&lt;/p&gt;&lt;input type=\"checkbox\"&gt;$(\":checkbox\").css(\"background-color\",\"yellow\"); :submit 提交按钮&lt;input type=&quot;submit&quot;&gt; 12&lt;input type=\"submit\"&gt;$(\":submit\").css(\"background-color\",\"yellow\"); :image 图片按钮&lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 12&lt;input type=\"image\" src=\"\"&gt;$(\":image\").css(\"background-color\",\"yellow\"); :reset 重置按钮&lt;input type=&quot;reset&quot;&gt; 12&lt;input type=&quot;reset&quot; src=&quot;&quot;&gt;$(&quot;:reset&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); :file 文件上传&lt;input type=&quot;file&quot;&gt; 12&lt;input type=\"file\"&gt;$(\":file\").css(\"background-color\",\"yellow\"); :hidden 隐藏域&lt;input type=&quot;hidden&quot;&gt; ,还可以获得&lt;xxx style=&quot;display:none&quot;&gt; 123&lt;input type=\"hidden\"&gt;&lt;div style=\"display:none\"&gt;&lt;/div&gt;$(\":hidden\").css(\"background-color\",\"yellow\"); :button 所有普通按钮。&lt;button &gt; 或 &lt;input type=&quot;button&quot;&gt; 123&lt;button &gt;button&lt;/button&gt;&lt;input type=\"button\"&gt;$(\":button\").css(\"background-color\",\"yellow\"); select 下拉列表 (没有:号） 1234567&lt;select&gt; &lt;option value =\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt;$(\"select\").css(\"background-color\",\"yellow\"); textarea 多行文本框（没有:号） 12&lt;textarea&gt;&lt;/textarea&gt;$(\"textarea\").css(\"background-color\",\"yellow\"); 1.9 表单独享属性过滤选择器:enabled 可用 123&lt;input type='text'&gt;&lt;input type='text' disabled=\"disabled\"&gt;$(\"input:enabled\").val(\"aaaa\"); :disabled 不可用。&lt;xxx disabled=&quot;disabled&quot;&gt; 或&lt;xxx disabled=&quot;&quot;&gt; 或&lt;xxx disabled&gt; 12345&lt;input type='text'&gt;&lt;input type='text' disable=\"\"&gt;&lt;input type='text' disable&gt;&lt;input type='text' disabled=\"disabled\"&gt;$(\"input:disabled\").val(\"bbbb\"); :checked 选中（单选框radio、复选框 checkbox） 12345678910111213141516&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"今日话题\" /&gt;今日话题 &lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"视觉焦点\" /&gt;视觉焦点&lt;/p&gt;&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"财经\" /&gt;财经&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"汽车\" checked=\"\"/&gt;汽车&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"科技\" /&gt;科技&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"房产\" /&gt;房产&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"旅游\" /&gt;旅游&lt;/p&gt;&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" checked=\"\"/&gt;苹果 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;桃子 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;香蕉 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;梨 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;其它 &lt;/label&gt; $(\":checked\").css(\"background-color\",\"yellow\"); :selected 选择（下拉列表 select option） 1234567&lt;select&gt; &lt;option value =\"volvo\" selected=\"\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt;$(\"selected\").css(\"background-color\",\"yellow\"); 二.jQuery属性和CSS2.1 属性操作attr() 设置单个属性 12&lt;img title=\"\"&gt;$('img').attr('title','哎哟，不错哦'); 设置多个属性 123456&lt;img title=\"\" alt=\"\" &gt;$('img').attr(&#123; title:'image', alt:'缺省', style:'opacity:.5'&#125;); 获取属性 12&lt;img title=\"images\" alt=\"\" &gt;var oTitle = $('img').attr('title'); removeattr() 移除属性 12&lt;img title=\"images\" alt=\"\" &gt;$('img').removeAttr('title'); prop() 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 设置和获取属性 12345&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" checked=\"\"/&gt;苹果 &lt;/label&gt; // 设置属性$(':checked').prop('checked',true);// 获取属性$(':checked').prop('checked');// 返回true或者false val()/text()/html() 123$obj.val() 获取或者设置表单元素的value属性的值$obj.html() 对应innerHTML$obj.text() 对应innerText/textContent，处理了浏览器的兼容性。注意点：如果获取jquery对象text属性的时候jquery对象是一个数组，那么此时会把数组中所有元素的文本都获取到 2.2 CSS操作css() css(name) 获得指定名称的css值css(name ,value) 设置一对值css(prop) 设置一组值 操作单个样式 12&lt;div&gt;&lt;/div&gt;$(\"div\").css(\"border\",\"1px solid red\"); 操作多个样式 1234567&lt;div&gt;&lt;/div&gt;$(\"div\").css(&#123; \"width\":\"300px\", \"height\":\"50px\", \"font-size\":\"60px\", \"color\":\"blue\"&#125;); 获取样式 12&lt;div style='background-color:'red'&gt;&lt;/div&gt;$('div').css('background-color'); 设置样式操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取样式操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class类操作 addClass(“A”) 追加一个类removeClass(“A”) 将指定类移除toggleClass(“A”) 如果有A将移除，如果没有将添加。hasClass(“A”) 用于判断是否含有指定样式，返回值为true false 三. jQuery尺寸和位置操作3.1 CSS尺寸 height() 获得 或 设置 高度 //不包括内边距、边框和外边距width()获得 或 设置 宽度 12345&lt;div style=\"height:100px;width:110px\"&gt;&lt;/div&gt;$(\"div\").css(\"border\",\"1px solid red\");alert($(\"div\").height()); //数字类型alert($(\"div\").width());$(\"div\").height(\"300px\"); //设置高度，值可以是数字也可以是字符串 获取可视区宽高度 1234// 获取可视区宽度$(window).width();// 获取可视区高度$(window).height(); css获取到的宽高是带 px 的,需要数值则需要用parseInt()转换 css设置样式可不加px 3.2 innerWidth/outerWidth innerWidth()/innerHeight() 方法返回元素的宽度/高度（包括内边距）。 —&gt;clientWidthouterWidth()/outerHeight() 方法返回元素的宽度/高度（包括内边距和边框）。 —&gt;offsetWidthouterWidth(true)/outerHeight(true) 方法返回元素的宽度/高度（包括内边距、边框和外边距）。 3.3 scrollTop与scrollLeft获取页面滚出的位置 1234// 获取页面被滚出的高度$(window).scrollTop();// 获取页面被滚出的宽度$(window).scrollLeft(); 3.4 offset方法与position方法offset() offset方法获取元素距离document的位置 1234// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//设置位置$(\"div\").offset(&#123;\"top\":0,\"left\":0&#125;);//不用加px position方法获取的是元素距离第一个定位了的父元素(offsetParent)的位置 获取相对于其最近的有定位的父元素的位置。 12// position仅用于获取当前元素相对于父元素的位置，不可以设置。如果非要设置，需要引入jquery-ui.js$(selector).position(); 四.jQuery文档处理4.1 创建节点1$('&lt;span&gt;这是一个span元素&lt;/span&gt;'); 4.2 内部插入(不可重复插入)第一种方式 123456789101112131415A.append(B) 将B插入到A的内部后面（之后的串联操作，操作A） &lt;A&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;B&gt;&lt;/B&gt; &lt;A&gt; A.prepend(B) 将B插入到A的内部前面 &lt;A&gt; &lt;B&gt;&lt;/B&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;A&gt; 第二种方式 12345678910111213A.appendTo(B) 将A插入到B的内部后面 （之后的串联操作，操作A） &lt;A&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;B&gt;&lt;/B&gt; &lt;A&gt;A.prependTo(B) 将A插入到B的内部前面 &lt;B&gt; &lt;A&gt;&lt;/A&gt; .... &lt;B&gt; 4.3 外部插入第一种方法 12345678A.insertAfter(B) , 将A插入到B后面（同级） ...... &lt;B&gt;&lt;/B&gt; &lt;A&gt;&lt;/A&gt;A.insertBefore(B) 将A插入到B前面 &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt; ...... 第二种方法 12345678A.after(B) , 将B插入到A后面（同级） ...... &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt;A.before(B) ，将B插入到A前面 &lt;B&gt;&lt;/B&gt; &lt;A&gt;&lt;/A&gt; ...... 4.4 删除节点 empty() 清空标签体（清空文本节点和子节点）,自身保留(清理门户),会清除子元素上绑定的内容remove() 删除当前对象。如果之后再使用，元素本身保留，绑定事件 或 绑定数据 都会被移除detach() 删除当前对象。如果之后再使用，元素本身保留，绑定事件 或 绑定数据 都保留 注意:$(‘div’).html(‘’);// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 4.5 复制节点clone(even) even ：指示事件处理函数是否会被复制。V1.5以上版本默认值是：false 1234&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"body\").append($('div').clone(true)); 4.6 替换节点A.replaceWith(B) ，使用B将A替换掉 12&lt;p&gt;p&lt;/p&gt;$(\"p\").replaceWith(\"&lt;a&gt;xxxx&lt;/a&gt;\"); A.replaceAll(B) ，使用A替换B 1234&lt;p&gt;p&lt;/p&gt;&lt;p&gt;p&lt;/p&gt;&lt;p&gt;p&lt;/p&gt;$(\"&lt;a&gt;ssss&lt;/a&gt;\").replaceAll(\"p\");","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Javascript冒泡事件机制","slug":"Javascript冒泡事件机制","date":"2017-11-24T13:41:43.000Z","updated":"2019-04-21T13:52:47.236Z","comments":true,"path":"passages/Javascript冒泡事件机制/","link":"","permalink":"http://yoursite.com/passages/Javascript冒泡事件机制/","excerpt":"","text":"Javascript冒泡事件机制1.事件在浏览器端的应用平台，基本是都是用事件来驱动的 事件：某个动作发生，然后做出相应的动作 浏览器中，事件表示某些事情发生的信号。 2.冒泡机制首先，什么是冒泡？ 想象一下，当水底有气泡的时候，气泡是从最底部由深向浅向上上升，在这过程，气泡会经过不同深度的水。 联想：气泡就相当于事件，水就如同整个Dom树，事件从Dom树的底部层层向上传递，直到达到Dom的根节点 案例分析我们写一个HTML页面，其中包含三个Dom元素，div外，div中，span内，其中外包含中包含内。 1234567&lt;body id=\"body\"&gt; &lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt; &lt;sapn id=\"span\"&gt;我是span&lt;/sapn&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819#box1 &#123; width: 300px; height: 300px; background-color: skyblue;&#125;#box2 &#123; width: 200px; height: 200px; background-color: pink;&#125;#span &#123; display: inline-block; width: 100px; height: 100px; background-color: yellow;&#125;#body &#123; background-color: rgb(0, 252, 134);&#125; 界面如下： 接下来我们实现如下功能： body添加click事件监听，当body捕获到event事件时，输出事件发生的事件和触发事件的节点信息 12345678&lt;script&gt; window.onload = function() &#123; document.getElementById(\"body\").addEventListener(\"click\",eventHandler); &#125; function eventHandler(event) &#123; console.log(\"时间：\"+new Date(event.timeStamp)+\" 产生事件的节点：\" + event.target.id +\" 当前节点：\"+event.currentTarget.id); &#125; &lt;/script&gt; 我们依次点击“这是span”，div中，div外和body，得到以下信息 我们可以得出结论： 无论是body，body的子元素div外，还是div外的子元素div中，以及span，当这些被点击时，会产生click事件，并且最后都会传到body被捕获，接着再调用相关处理时间函数。 示意图如下： 事件在传递过程中会传递以下信息： 事件发生时间+事件发声地点+事件类型+事件当前处理者+其他 3.终止事件冒泡现在，我们这样，当点击各自的部分时，我们让他们各自产生提示信息 12345678910111213&lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; console.log(\"我是最外层div。\"); &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; console.log(\"我是中间div。\"); &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; console.log(\"我是span。\"); &#125;); &#125; &lt;/script&gt; 当我们点击span时，会弹出以下信息 显示我们并不想要这样，我们只想点击哪部分就显示哪部分的提示。那么为什么会这样呢？原因就在于冒泡的机制，当我们点击span时，span会将事件冒泡给div中，然后再冒泡给div外。当冒泡到相应的元素是会触发响应函数，在从内向外的传递过程中，依次打印了各自的信息。 原理清楚了，那么该如何阻止事件的冒泡呢？ 方法一我们想象一下，一个气泡正从水底向上冒，现在我们在水中，我们不想让他向上冒了怎么办？ 对，把他扎破。没有了气泡自然也就不会有冒泡了。 类似，在某个节点中，如果不想让他处理向上传递，我们可以终止事件的冒泡： event.stopPropagation() 这个函数可以终止事件的分发，使之不会向上层传递 我们修改script的内容 12345678910111213141516&lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; console.log(\"我是最外层div。\"); event.stopPropagation(); &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; console.log(\"我是中间div。\"); event.stopPropagation(); &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; console.log(\"我是span。\"); event.stopPropagation(); &#125;); &#125; &lt;/script&gt; 当我们再次点击span时，只会有span提示。 方法二讲方法二之前，我们先分清最初触发事件的节点引用和当前处理事件节点的引用 最初触发事件的节点引用:即事件产生的节点 当前处理事件节点的引用 ：即处理当前事件的节点 事件产生的节点只有一个，而在传递的过程中，节点都可以处理事件。那么我们可以设置： 节点只处理自己触发的事件,不是自己产生的事件就不处理。 event.target 引用了产生此event对象的dom 节点，而event.currrentTarget 则引用了当前处理节点，我们可以通过对比这两个target 是否相等来决定是否处理事件。 例如：当span 点击事件，产生一个event 事件对象，event.target 指向了span元素，span处理此事件时，event.currentTarget 指向的也是span元素，这时判断两者相等，则执行相应的处理函数。而事件传递给 div中 的时候，event.currentTarget变成 div中，这时候判断二者不相等，即事件不是div中本身产生的，就不作响应处理逻辑。 因此我们修改script代码： 1234567891011121314151617181920212223 &lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是最外层div。\"); &#125; &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是中间div。\"); &#125; &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是span。\"); &#125; &#125;);&#125; &lt;/script&gt; 同样可以达到我们想要的效果 那么这两个方法有什么不同呢？ 比较： 方法一在于取消事件冒泡，即当某些节点取消冒泡后，事件不会再传递； 方法二在于不阻止冒泡，过滤需要处理的事件，事件处理后还会继续传递； 方法一缺点： 为了实现点击特定的元素显示对应的信息，方法一要求每个元素的子元素也必须终止事件的冒泡传递 。 比如，当span 元素的处理函数没有执行冒泡终止，则事件会传到div中上，这样会造成div中 的提示信息 方法二缺点： 增加了代码冗余和逻辑上的复杂度 当有几十个，几百个，那么要求每一层都要有if(event.target == event.currentTarget) 方法改进我们看方法二， 方法二的原理是 元素收到事件后，判断事件是否符合要求，然后做相应的处理，然后事件继续冒泡往上传递； 既然事件是冒泡传递的，那可不可以让某个父节点统一处理事件，通过判断事件的发生地（即事件产生的节点），然后做出相应的处理呢？ 答案是可以的，下面通过给body 元素添加事件监听，然后通过判断event.target 然后对不同的target产生不同的行为。 12345678910111213141516171819&lt;script&gt; window.onload = function() &#123; document.getElementById(\"body\").addEventListener(\"click\",eventPerformed); &#125; function eventPerformed(event) &#123; var target = event.target; switch (target.id) &#123; case \"span\": console.log(\"我是span。\"); break; case \"box1\": console.log(\"我是外层div。\"); break; case \"box2\": console.log(\"我是中间div。\"); break; &#125; &#125; &lt;/script&gt; 结果是点击谁谁会提示！ 我们把本来每个元素都要有的处理函数，都交给了其祖父节点body 元素来完成了，也就是说，span,div中,div外 将自己的响应逻辑委托给body，让它来完成相应逻辑，自己不实现相应逻辑，这个模式，就是所谓的事件委托。 如图 本篇博客参考 https://blog.csdn.net/u010349169/article/details/23927347","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"TODOS案例（二）","slug":"TODOS案例（二）","date":"2017-11-19T13:52:50.000Z","updated":"2019-04-17T14:21:18.236Z","comments":true,"path":"passages/TODOS案例（二）/","link":"","permalink":"http://yoursite.com/passages/TODOS案例（二）/","excerpt":"","text":"TODOS案例（二）界面样式设计上一期我们简单对页面元素进行了添加，本篇将对界面样式进行设置和布局。 最终呈现的效果如下图 先对input框进行调节，给input框一个边框以及颜色，内外边距统一为20rpx，边框圆角统一为5rpx，盒子阴影设置为5rpx模糊程度。 考虑到内部图片和输入框的横向排列，我们采用flex布局方式，给.search的display设为flex，为了使内部组件在水平线上对齐，设置align-item为center 代码如下 123456789.search &#123; border: 1rpx solid #e0e0e0; margin: 20rpx; padding: 20rpx; border-radius: 5rpx; box-shadow: 0 0 5rpx #e0e0e0; display: flex; align-items: center;&#125; 再设置添加图片大小以及设置和右侧文本框的距离： 12345.search image &#123; width: 45rpx; height: 45rpx; margin-right: 20rpx;&#125; 这样input部分调整完成！！ 下面开始调整中部的样式，我们同样给边框设置相同样式！ 1234567.todos &#123; border: 1rpx solid #e0e0e0; margin: 20rpx; padding: 20rpx; border-radius: 5rpx; box-shadow: 0 0 5rpx #e0e0e0;&#125; 在对内部item组件进行调整，并且同样采取flex布局，两端的icon我们在属性里设置为30大小，中间文本框采用flex自动撑开 123456789101112.todos .item &#123; padding: 20rpx; border-bottom: 1rpx solid #e0e0e0; display: flex; align-items: center;&#125;.todos .item text &#123; flex:1; font-size: 30rpx; color: #888; margin-left: 20rpx;&#125; 为了样式美观，我们将最后一个item的下边框去除 123.todos .item:last-child &#123; border-bottom: 0;&#125; 最后设置底部部分，简单采用flex布局，并使布局方式justify-content设置为space-between 至此样式布局完成！！！ 下篇将介绍如何抽象数据模型。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"TODOS案例（一）","slug":"TODOS案例（一）","date":"2017-11-18T14:38:07.000Z","updated":"2019-04-17T00:30:49.676Z","comments":true,"path":"passages/TODOS案例（一）/","link":"","permalink":"http://yoursite.com/passages/TODOS案例（一）/","excerpt":"","text":"界面结构设计通过对微信小程序的学习，我们简单通过所学的知识设计一个TODOS案例，整个TODOS包括添加事件功能，标记功能，删除事件功能，标记所有功能，剩余事件提醒功能以及清除所有事件功能。 本片微博将分为14篇对本案例过程进行详细介绍。 下面开始第一部分：界面结构设计。 首先在pages中新建todos页面以及内容 在app.json中注册主页面以及导航栏的标题 12345678910111213&#123; \"pages\": [ \"pages/todos/todos\" ], \"window\": &#123; \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"TODOS\", \"navigationBarTextStyle\": \"black\" &#125;, \"sitemapLocation\": \"sitemap.json\"&#125; 接下来，我们根据界面图先设计好框架 整个界面可分为上中下三部分： 第一部分包括添加事件按钮，input输入框 第二部分包括事件完成勾选icon，事件展示text，以及事件清除icon 第三部分为底部事件提醒以及功能按钮 12345678910111213141516171819202122232425262728&lt;view class=\"container\"&gt; &lt;view class=\"search\"&gt; &lt;image src=\"../../images/plus.png\" &gt;&lt;/image&gt; &lt;input type='text' placeholder='Anything here ...'&gt;&lt;/input&gt; &lt;/view&gt; &lt;view class=\"todos\"&gt; &lt;view class='item'&gt; &lt;icon type='success'&gt;&lt;/icon&gt; &lt;text&gt;Learning HTML&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class='item'&gt; &lt;icon type='circle'&gt;&lt;/icon&gt; &lt;text&gt;Learning CSS&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class='item'&gt; &lt;icon type='success'&gt;&lt;/icon&gt; &lt;text&gt;Learning JS&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"footer\"&gt; &lt;text&gt;Toggle ALL&lt;/text&gt; &lt;text&gt;0 item left&lt;/text&gt; &lt;text&gt;Clear&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 代码中的text文档暂时用文字代表，之后通过事件绑定进行渲染 整个框架搭建完成后如图所示","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"伸缩布局","slug":"伸缩布局","date":"2017-11-16T11:21:25.000Z","updated":"2019-04-16T12:43:32.082Z","comments":true,"path":"passages/伸缩布局/","link":"","permalink":"http://yoursite.com/passages/伸缩布局/","excerpt":"","text":"Flex伸缩布局Flexible意为可伸缩的，Box意为盒子，可以理解为一种新式的盒模型——伸缩盒模型。由CSS3规范提出，这是在原有的大家非常熟悉的block, inline-block, inline的基础上延伸出的新一代布局模式。 伸缩的基本概念 1.Flex container即伸缩盒容器，可以理解为将要被分的房子，分之前需要将display属性声明为flex或者inline-flex 2.Flex item即伸缩项可以理解为房子里的居民，他们会占有一定的住房面积，我们先用代码来解释一下 12345&lt;div class=\"container\"&gt; &lt;div class=\"item2\"&gt;&lt;/div&gt; &lt;div class=\"item3\"&gt;&lt;/div&gt; &lt;div class=\"item4\"&gt;&lt;/div&gt; &lt;/div&gt; 样式设置为 1234567891011121314151617181920212223 .container &#123; width: 300px; height: 100px; display: flex; &#125;.item1 &#123; flex: 1; width: 100px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 100px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 1; width: 100px; height: 100px; background-color: red; &#125; 结果如图所示: 可以看到房子被平分成三分！ 但是有人如果想住大点的房子，我们可以直接改变flex的值来实现，例如: 123456789101112131415161718.item1 &#123; flex: 1; width: 100px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 100px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 2; width: 100px; height: 100px; background-color: red; &#125; 3.Axes轴图中分别标注了主轴和次轴，但是事实上那一条是主轴可以由我们自己规定。 flex-direction 此属性规定哪条轴为主轴。 justify-content 此属性设置了伸缩项在主轴方向上的排列方式，这个稍后解释。 align-items 此属性和上面的justify-content相对，表示伸缩项在次轴上的排列方式。 align-self 此属性规定某一个特定的伸缩项元素在次轴上的布局方式，在某个元素上设置该属性会覆盖它的align-items属性。也就是这个属性会让某个元素更有个性，不走寻常路~ 4.flex-direction当我们不想沿着默认的方向分房子的时候，我们可以改变flex-direction属性的值来改变主轴和方向，该属性默认的取值为row； 当取值为row-reverse时，伸缩项逆置： 123456.container &#123; width: 300px; height: 100px; display: flex; flex-direction: row-reverse; &#125; 当此属性设置为column时，主次轴就会对调，元素的排列方向也会随之改变： 123456.container &#123; width: 300px; height: 100px; display: flex; flex-direction: column; &#125; 至于flex: column-reverse的含义和row-reverse类似 5.justify-contents有的时候，大家挨着住，一点空隙都没有也会很难受，连个过道都没有，隐私也不能保证对吧。这个时候，我们可以改变分配政策了，不再按比例分配，而是定额分配，每个人的面积是确定的。多出的房屋面积改成公共区域。 为了更好地看见区别，我们将每一个item宽度缩小 123456789101112131415161718.item1 &#123; flex: 1; width: 80px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 80px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 2; width: 80px; height: 100px; background-color: red; &#125; 设定了width属性后也要记得去掉flex属性的声明，不然flex属性的效果仍然会把width覆盖掉同时，如果width属性也不设定的话，元素宽度会表现为内容的宽度，即当伸缩项内部无内容时，将不会进行渲染，其表现就和display: none;一样。 这时，在容器上声明justify-content属性就可以安排伸缩项的位置了： 123.contianer &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 6.align-items这项属性会改变次轴上元素排列的方式，对于本例来说原来次轴方向上元素的高度是表现为height: 100%;的，设定了align-items属性后，其高度表现就会发生改变了。 123.content &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 至于各项的作用，可以动手试试！ 7.order在伸缩项上声明此属性，可以无视HTML结构的顺序而按照order从小到大的顺序沿flex-direction方向排列。比如： 123456789101112131415161718192021.item1 &#123; flex: 1; width: 80px; height: 100px; background-color: blue; order: 3;&#125;.item2 &#123; flex: 1; width: 80px; height: 100px; background-color: yellow; order: 1；&#125;.item3 &#123; flex: 2; width: 80px; height: 100px; background-color: red; order: 2;&#125; 8.flex-wrap此属性的默认值为nowrap，也就是忽略伸缩项的宽度，管你要多少住房面积，通通按照flex属性说好的分配，不许换行。 为了方便观察，我们先将盒子宽度设为150px； 123456789101112131415.item1 &#123; width: 150px; height: 100px; background-color: blue; order: 3; &#125; .container &#123; width: 300px; height: 100px; display: flex; flex-direction: row; flex-wrap: nowrap;//wrap &#125; 9.flex-grow，flex-shrink 和 flex-basis上文提到的flex属性实际上是这三个属性的简写形式。这三个属性有相似性，都是表示项与项之间分配空间的相对比例关系，不同之处在于： flex-grow属性：属性值为该伸缩项所占空间相对于其他伸缩项（声明了flex相关属性的项）的比值。 flex-shrink属性：该伸缩项相对于其他伸缩项缩小的比值，也就是说当flex-shrink: 3;时，该项所占空间为其他项的1/3。flex-basis属性：属性值为该项所占空间占容器空间的百分比。 注意：对于flex-basis属性，当所有项的属性值相加&lt;=100%时，会严格按照百分比值来渲染。当属性值相加&gt;100%时，元素并不会溢出，而是表现为两两之间所占空间大小遵循相互的百分比比值。也就是说当存在三个伸缩项且flex-basis值都为50%时，表现行为与三个项均为flex: 1;一样。 Flexible Boxes布局模式在响应式开发中尤其好用，对不同的终端，设置元素之间的空间分配关系将会变成一件非常简单的事。后期微信小程序中也是十分好用，伸缩盒布局和响应式布局中流行的流体布局哪种更好，还是可以结合起来，就看各位开发者发挥自己的聪明才智了！","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"JS学习总结（三）","slug":"JS学习总结（三）","date":"2017-10-11T13:06:48.000Z","updated":"2019-04-07T07:32:11.262Z","comments":true,"path":"passages/JS学习总结（三）/","link":"","permalink":"http://yoursite.com/passages/JS学习总结（三）/","excerpt":"","text":"一，script标签书写位置js的代码可以分三个地方写: 1.在html的文件中,script的标签中写js代码2.js代码可以在html的标签中写—3.在js文件中可以写js代码,但是需要在html的页面中引入 script的标签中的src=”js的路径” 二，js代码的注意问题 1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行3.script的标签中可以写什么内容 type=”text/javascript”是标准写法或者写language=”JavaScript”都可以但是,目前在我们的html页面中,type和language都可以省略,原因:html是遵循h5的标准4.有可能会出现这种情况:script标签中可能同时出现type和language的写法.5.script标签在页面中可以出现多对6.script标签一般是放在body的标签的最后的,有的时候会在head标签中,目前讲课的时候都在body标签的后面(body中的最后)7.如果script标签是引入外部js文件的作用,那么这对标签中不要写任何的js代码,如果要写,重新写一对script标签,里面写代码 三，变量 变量:========&gt; 操作的数据都是在内存中操作 js中存储数据使用变量的方式(名字,值—&gt;数据) js中声明变量都用var—-&gt;存储数据,数据应该有对应的数据类型 js中的字符串类型的值都用双引号或者单引号 存储一个数字10 变量的声明及赋值 var num=10; 存储一个名字 var name=&#39;小黑&#39;; 变量—作用,存储数据的或者是操作数据 变量声明(有var 有变量名字,没有值) 变量初始化(有var 有变量名字,有值) 变量声明的方式: 123456789101112131415 //一次性声明多个变量 var x,y,z,k,j;//都是声明,没有赋值//变量的初始化(变量声明的同时并且赋值了)// = 的意义:赋值的含义var number = 10;//存储一个5var number2 = 5;//存储一个人的名字var name = \"小黑\";//存储真(true)var flag = true;//存储一个null---&gt;相当于是var obj = new Object();// var 变量名字; 四，变量总结 变量作用:用来操作数据的(可以存储,可以读取) 变量的声明:没有赋值 var 变量名; 变量的初始化:有赋值 var 变量名=值; 注意的基本的代码的规范 js中声明变量都用var js中的每一行代码结束都应该有分号;(写代码有分号的习惯) js中的大小写是区分的: var N=10; n js中的字符串可以使用单引号,也可以使用双引号,目前我们暂时使用双引号 变量名的注意问题—变量名的命名规范,要遵循驼峰命名法 1.变量的名字要有意义, 2.变量名有一定的规范:一般以字母,$符号,下划线开头,中间或者后面可以有$符号,字母,数字 3.变量名一般都是小写的 4.变量名如果是多个单词,第一个单词的首字母是小写的,后面的所有的单词的首字母都是大写的,这种命名方式称为:驼峰命名法 5.不能使用关键字(系统自带的一些单词,不能使用) 6.不会单词用拼音,拼音也要遵循驼峰命名法 var bigNumber=10; 声明变量并初始化—变量的初始化—-声明变量赋值 声明多个变量然后一个一个的赋值 声明多个变量并且赋值 123456789101112131415var num=100;//输出这个变量的值alert(num);//弹框//浏览器的控制台在浏览器中的开发人员工具中(快捷键:F12)的console的选项中console.log(num);//把内容输出在浏览器的控制台中// //依次的赋值num1=10;num2=20;num3=30;var num1=10,num2=20,num3=30;var num=10;var $break=10;var shuZi=10; 五，数字交换的三种方式变量的交换的第一个思路:使用第三方的变量进行交换123456789var num2=20;// //把num1这个变量的值取出来放在temp变量中var temp=num1;// //把num2这个变量的值取出来放在num1变量中num1=num2;// //把temp变量的值取出来放在num2变量中num2=temp;console.log(num1);//20console.log(num2);//10 第二种方式交换:一般适用于数字的交换 12345678var num2 = 20;// //把num1的变量中的值和num2变量中的值,取出来相加,重新赋值给num1这个变量num1 = num1 + num2;//30// //num1变量的值和num2变量的值取出来,相减的结果重新赋值给num2num2 = num1 - num2;//10// //num1变量的值和num2变量的值取出来,相减的结果重新赋值给num1num1 = num1 - num2;//20console.log(num1, num2); Ctrl+Alt+L—–&gt;格式化代码的(设置代码有很好的格式,代码是错误的,这个快捷键是没有效果) 注意；变量的名字是不能重名 123var num1=10;var num1=20;console.log(num1); 扩展的变量的交换:只需要看代码,不需要理解—位运算12345var num2 = 20;num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2;console.log(num1, num2); 六，数据类型声明变量并初始化var num=10;js中的数据类型有哪些?js中的原始数据类型:number,string,boolean,null,undefined,object number:数字类型(整数和小数) string:字符串类型(的值一般都是用单引号或者是双引号括起来) “34” boolean:布尔类型(值只有两个,true(真1),false(假0)) null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null undefined:未定义,值只有一个:undefined 什么情况下的结果是undefined 变量声明了,没有赋值,结果是undefined 函数没有明确返回值,如果接收了,结果也是undefined 如果一个变量的结果是undefined和一个数字进行计算,结果:NaN不是一个数字,也没有意义 object:对象—-&gt; 1234var num; var num;console.log(num+10);//NaN-----not an number----&gt;不是一个数字`var num;console.log(num);` 如何获取这个变量的数据类型是什么? 使用typeof 来获取typeof 的使用的语法 都可以获取这个变量的数据类型是什么! typeof 变量名 typeof(变量名) 12345678910111213141516var str = \"小白\";var flag = true;var nll = null;var undef;var obj = new Object();//是使用typeof 获取变量的类型console.log(typeof num);//numberconsole.log(typeof str);//stringconsole.log(typeof flag);//booleanconsole.log(String(nll));//是nullconsole.log(typeof nll);//不是nullconsole.log(typeof undef);//undefinedconsole.log(typeof obj);//objectconsole.log(typeof(num));// console.log(\"10\");// console.log(10); 七，数字类型 数字类型:number类型 无论是整数还是小数都是数字类型 不要用小数验证小数 不要使用NaN判断是不是NaN，应该使用isNaN(值或者是变量) 想要表示十进制:就是正常的数字 想要表示八进制:以0开头 想要表示十六进制:0x开头 八，字符串类型12var str=\"10\";//字符串var str2='20';//字符串 字符串可以使用单引号,也可以使用双引号 字符串的长度如何获取? 变量名.length 123456var str=\"what are you no sha lei\";// //字符串的个数有多少个?这个字符串的长度是多少console.log(str.length);//var str1=\"fdshfjworwoijpfskj;akjfpojfiwnmoiwajdoiwajiwaewowj\";console.log(str1.length); html中的转义符: &lt; &lt; &gt; &gt; 空格: &nbsp;js中的字符串里也有转义符 tab键—-水平制表符 123console.log(\"哈哈\\t嘎嘎\");console.log(\"哈哈\\\"嘎嘎\");console.log('哈哈\\'嘎嘎');` 字符串的拼接: 使用+可以把多个字符串放在一起形成一个字符串只要有一个是字符串,其他的是数字,那么结果也是拼接,不是相加如果有一个是字符串,另一个不是字符串,使用- 号,此时会发生计算 1234567891011121314151617181920var str1=\"您好\";var str2=\"我好\";console.log(str1+str2);console.log(\"哈哈\"+\"嘎嘎\"+\"嘿嘿\");var str1=\"10\";var str2=\"20\";console.log(str1+str2);var str1=\"10\";var str2=20;console.log(str1+str2);var str1 = \"10\";var str2 = 5;// //浏览器帮助我们自动的把字符串类型转成了数字类型,这种方式叫:隐式转换console.log(str1-str2);var str1=\"10\";var str2=5;console.log(str1*str2); 九，布尔类型布尔类型:的值有两个,一个是true(真),一个是false(假) 123456var flag=1;console.log(flag);var fdf=null;//var num=0; 十，类型转换其他类型转数字类型:三种方式: 1.parseInt();//转整数 123456console.log(parseInt(\"10\"));//10console.log(parseInt(\"10afrswfdsf\"));//10console.log(parseInt(\"g10\"));//NaNconsole.log(parseInt(\"1fds0\"));//1console.log(parseInt(\"10.98\"));//10console.log(parseInt(\"10.98fdsfd\"));//10 2.parseFloat()//转小数 123456console.log(parseFloat(\"10\"));//10console.log(parseFloat(\"10afrswfdsf\"));//10console.log(parseFloat(\"g10\"));//NaNconsole.log(parseFloat(\"1fds0\"));//1console.log(parseFloat(\"10.98\"));//10.98console.log(parseFloat(\"10.98fdsfd\"));//10.98 3.Number();//转数字 123456console.log(Number(\"10\"));//10console.log(Number(\"10afrswfdsf\"));//NaNconsole.log(Number(\"g10\"));//NaNconsole.log(Number(\"1fds0\"));//NaNconsole.log(Number(\"10.98\"));//10.98console.log(Number(\"10.98fdsfd\"));//NaN 总结:想要转整数用parseInt(),想要转小数用parseFloat()想要转数字:Number();要比上面的两种方式严格 其他类型转字符串类型 1.toString() 12var num=10;console.log(num.toString());//字符串类型 String() 12var num1=20;console.log(String(num1)); 如果变量有意义调用.toString()使用转换 如果变量没有意义使用String()转换 12345678910var num2;console.log(num2.toString());var num3=null;console.log(num3.toString()); //这个可以var num2;console.log(String(num2));var num3=null;console.log(String(num3)); 其他类型转布尔类型 Boolean(值); 12345678910111213//console.log(Boolean(1));//trueconsole.log(Boolean(0));//falseconsole.log(Boolean(11));//trueconsole.log(Boolean(-10));//trueconsole.log(Boolean(\"哈哈\"));//trueconsole.log(Boolean(\"\"));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//falsevar str=10;console.log(+str); 十一，操作符 操作符:一些符号—–用来计算 算数运算符: + - * / % 算数运算表达式:由算数运算符连接起来的表达式 一元运算符: 这个操作符只需要一个操作数就可以运算的符号 ++ – 二元运算符: 这个操作符需要两个操作数就可以运算, 三元运算符: —–不讲,明天讲 复合运算符: += -= *= /= %= 复合运算表达式:由复合运算符连接起来的表达式 var num=10; num+=10;------&gt;就是:num=num+10; console.log(num);20 关系运算符: &gt; &lt; &gt;= &lt;= ==不严格的 ===严格的 !=不严格的不等 !==严格的不等 关系运算表达式:由关系运算符连接起来的表达式 关系运算表达式的结果是布尔类型 逻辑运算符: &amp;&amp;—逻辑与–并且 ||—逻辑或—或者 !—逻辑非—取反–取非 逻辑运算表达式:由逻辑运算符连接起来的表达式 表达式1&amp;&amp;表达式2 如果有一个为false,整个的结果就是false 表达式1||表达式2 如果有一个为true,整个的结果为true !表达式1 表达式1的结果是true,整个结果为false 表达式1的结果是false,整个结果为true 赋值运算符: = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var num1=10;var num2=20; //console.log(num1==num2&amp;&amp;5&gt;6); var num=20;console.log(num&gt;10||5&lt;0);var flag=false;console.log(!flag);var num=10;var sum=(num+10)*5;console.log(sum);var result = (4 &gt;= 6 || '人' != '狗' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true);console.log(result);//var num = 10;//var result2 =( 5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22');console.log(result2);var num=20;var result=num/3;//num变量与3取余---&gt;10/3的余数console.log(parseInt(result));var num=20;var result=num%3;//num变量与3取余---&gt;10/3的余数console.log(result);var num=10;var sum=(num+10)+10;var num = 20;num %= 5; // // num=num-5;console.log(num);var str=\"5\";var num=5;console.log(str===num);console.log(5&gt;10);//falseconsole.log(5&gt;=5);//trueconsole.log(5&gt;3);//trueconsole.log(5==10);//false 字面量: 把一个值直接赋值给一个变量 声明变量并初始化 12345678var num=10;//var flag=true;//var str=\"哈哈哈\";//var y=10;var n=y;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html学习总结（一）","slug":"html学习总结（一）","date":"2017-10-03T06:39:18.000Z","updated":"2019-04-07T06:45:20.380Z","comments":true,"path":"passages/html学习总结（一）/","link":"","permalink":"http://yoursite.com/passages/html学习总结（一）/","excerpt":"","text":"一，浏览器内核1.浏览器内核可分为渲染引擎和js引擎： 渲染引擎:它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 JS 引擎:则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。 2.常见浏览器分类（1） Trident（IE内核） （2）Gecko（火狐） （3）Webkit（Safari） （4）Chromium（Chrome） （5）Presto 3.Web标准的构成主要包括结构，样式和行为三个方面 结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。 最重要表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 4.Html语法骨架1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; HTML标签： 作用所有HTML中标签的一个根节点。 最大的标签 根标签 head标签： 文档的头部 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 注意在head标签中我们必须要设置的标签是title title标签： 文档的标题 作用：让页面拥有一个属于自己的标题。 body标签：文档的主体 以后我们的页面内容 基本都是放到body里面的 body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） 5.HTML标签分类（1）双标签 1&lt;标签名&gt;内容&lt;/标签名&gt; （2）单标签 1&lt;标签名&gt; 6.HTML标签关系（1）嵌套关系 123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; （2）并列关系 12345&lt;head&gt; &lt;body&gt; &lt;/body&gt;&lt;/head&gt; 7.文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 8.字符集utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 9.HTML常用标签标题标签1&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 标题标签语义： 作为标题使用，并且依据重要性递减 基本语法格式 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 段落标签1&lt;p&gt; 文本内容 &lt;/p&gt; 标签语义：文章分段 水平线标签1&lt;hr&gt; 标签语义：将段落与段落之间隔开，使得文档结构清晰，层次分明 换行标签1&lt;br&gt; 文本格式化标签1234&lt;strong&gt;加粗&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;u&gt;下划线&lt;/u&gt; 10.图像标签1&lt;img src=\"图像URL\" /&gt; 标签属性：12345678&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …&gt; 内容 &lt;/标签名&gt;在上面的语法中：1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。3.任何标签的属性都有默认值，省略该属性则取默认值。采取 键值对 的格式 key=\"value\" 的格式 img属性1234567属性 属性值 描述src URL 路径alt 文本 不能显示时替换的文本title 文本 鼠标悬停的内容width px 宽度height px 高度border 数字 图像边框宽度 11.链接标签12345&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用target：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值，blank为在新窗口中打开方式 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 12.base标签123&lt;head&gt; &lt;base target=\"blank/self\"&gt;&lt;/head&gt; 标签语义：设置链接打开方式窗口是新建还是覆盖 13.锚点定位通过创建锚点，快速定位到目标内容 123451.使用“a href=”#id名&gt;“链接文本\"&lt;/a&gt;创建链接文本（被点击的） &lt;a href=\"#two\"&gt; 2.使用相应的id名标注跳转目标的位置。 &lt;h3 id=\"two\"&gt;第2集&lt;/h3&gt; 14.注释标签1&lt;!--注释语句--&gt; Ctrl+/ 注释的两个作用： 1.让部分代码不让浏览器执行 2.给程序员友好的提示 15.列表标签无序列表123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 中只能嵌套，直接在标签中输入其他标签或者文字的做法是不被允许的。 与之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 自定义列表12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 16.表格创建表格1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 1.table用于定义一个表格。 2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。 3.td /td：用于定义表格中的单元格，必须嵌套在标签中，一对 中包含几对，就表示该行中有多少列（或多少个单元格）。 注意： 中只能嵌套 标签，他就像一个容器，可以容纳所有的元素 表格属性border：设置表格边框的宽度（默认border=’0’） cellspacing：单元格与单元格之间的空白间距 cellspadding：单元格内容与边框之间的空白间距 width：表格宽度 height：表格高度 align：表格在网页中的水平对齐方式（left,right,center） 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构 在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示： ：用于定义表格的头部。 必须位于 标签中，一般包含网页的logo和导航等头部信息。 ：用于定义表格的主体。 位于标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题caption 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; 合并表格跨行合并：rowspan（跨多少行删多少行） 跨列合并：colspan（跨多少行删多少行） 17.div span标签 div在浏览器中表示一个小区域，不会增加任何的效果改变，而是语义变了，div中所有子元素是在一个小区域中。div是一个容器，里面什么都能放，设置包括它自己 。 span也是表示一个小区域，但是只能是文本级别的区域，也就是span中只能够放文字、图片、表单元素等信息。 现在的网页开发基本都是用div+css布局实现的。 div和span的使用123456789101112131415161718192021222324&lt;div&gt; &lt;h3&gt;中国主要城市&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;美国主要城市&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;伦敦&lt;/li&gt; &lt;li&gt;纽约&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt; 商品简介，商品简介 &lt;span&gt; &lt;a href=””&gt;详细信息&lt;/a&gt; &lt;a href=””&gt;购买&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 18.内联元素和块级元素 div标签（独占一行 block） （div,form,table,p,pre,h1~h6,dl,ol,ul）特点：块级元素独占一行，可以设置宽度和高度。如果不设置宽度，则默认宽度为父元素的宽度。 span标签（占一块 inline）(span,a,label ,select)特点：所有元素在一行显示。不能设置宽高。默认宽度为文字或者内容本身的宽度。 行内块元素（inline-block） (image input)特点：所有元素在一行显示，可以设置宽高(具备块级元素的特征，也具备行内元素的特征)。 19.表单标签 包括表单控件，提示信息，表单域 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。 用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 input控件text属性 &lt;input type=”text”&gt; 定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。 其它常用属性: l name:定义标签名称 l value:定义标签值 l size:定义输入字符的长度（可以输入超过指定长度的字符，但只会显示指定个数） l maxlength:定义可输入最大字符个数 l placeholder: 占位文字 password &lt;input type=”password”&gt; 定义密码字段。该字段中的字符被掩码. 其它常用属性: l name:定义标签名称 l value:定义标签值 l size:定义输入字段的长度 l maxlength:定义可输入最大字符个数 radio &lt;input type=”radio”&gt; 定义单选按钮。 其它常用属性: l name:定义标签名称.注意，对于单选按钮，如果要想做到单一选择，多个radion的name值必一样。 l value:定义标签值 l checked:定义该标签默认被选中。 checkbox &lt;input type=”checkbox”&gt; 定义复选框。 其它常用属性: l name:定义标签名称.注意，一组的checkbox它们的name值应该是一样的。 l value:定义标签值 l checked:定义该标签默认被选中。 file &lt;input type=”file”&gt; 定义输入字段和 “浏览”按钮，供文件上传。 其它常用属性: l name:定义标签名称 button &lt;input type=”button”&gt; 定义可点击按钮（多数情况下，用于通过JavaScript 启动脚本，如果不写什么也不发生） 其它常用属性: l name:定义标签名称 l value:按钮显示名称 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 其它常用属性: l name:定义标签名称 l value:按钮显示名称 reset 定义重置按钮。重置按钮会清除表单中的所有数据。 其它常用属性: l name:定义标签名称 l value:按钮显示名称 img 定义图像形式的提交按钮。 这个标签主要是用了替换submit按钮，因为默认产生的提交按钮并不漂亮，这个标签允许你采用指定的图片做为提交按钮。 其它常用属性: l name:定义标签名称 l src:定义作为提交按钮显示的图像的url l alt:定义作用图像的替代文本。 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。hidden &lt;inputtype=”hidden”&gt; 定义隐藏的输入字段。提交时服务端需要用到的信息，但是又不想让用户看到 常用属性: l name: 定义标签名称 l value:定义标签值 20.label标签label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for=\"male\"&gt;Male&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"male\" value=\"male\"&gt; 21.textarea控件如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 文本内容&lt;/textarea&gt; 22.下拉菜单123456&lt;select name=\"select\" multiple=\"multiple\" size=\"6\"&gt; &lt;option value=\"wx\" selected=\"selected\"&gt;无锡&lt;/option&gt; &lt;option value=\"wz\" selected=\"selected\"&gt;苏州&lt;/option&gt; &lt;option value=\"sh\" selected=\"selected\"&gt;上海&lt;/option&gt; &lt;option value=\"ks\" selected=\"selected\"&gt;昆山&lt;/option&gt;&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 23.其他标签上标下标1234567&lt;p&gt;This text contains &lt;sub&gt;subscript&lt;/sub&gt;&lt;/p&gt;&lt;p&gt;This text contains &lt;sup&gt;superscript&lt;/sup&gt;&lt;/p&gt; pre标签（照原样输出）123456&lt;pre&gt; 这是 预格式文本。 它保留了 空格 和换行。&lt;/pre&gt; iframeiframe 元素会创建包含另外一个文档的内联框架（即行内框架）。可以理解为浏览器中的浏览器 1iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。可以理解为浏览器中的浏览器 24.路径相对路径以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Hexo博客搭建完整流程","slug":"Hexo博客搭建完整流程","date":"2017-10-03T02:59:27.000Z","updated":"2019-04-01T09:20:26.606Z","comments":true,"path":"passages/Hexo博客搭建完整流程/","link":"","permalink":"http://yoursite.com/passages/Hexo博客搭建完整流程/","excerpt":"","text":"一，准备工作1.了解HexoHexo是高效的静态站点生成框架，它基于Node.js。 通过 Hexo 你可以使用Markdown 编写文章。 2.搭建Node.js环境搭建博客网站首先需要安装Node.js环境。 下载地址：http://nodejs.cn/download 测试安装：命令行使用node -v 、npm -v，查看显示版本号即成功。 Ps:大部分同学装的node版本是之前提供的5.0.0多的 hexo的初始化步骤中会出现报错，需要重新装最新的版本（10.0.0多的） 3.安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下（Windows+R+cmd）使用如下命令： npm install hexo-cli -g 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统 使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。 下载地址：https://git-scm.com/downloads 测试安装:右击鼠标，如果有 Git GUI here Git Bash here 两个选项 即安装成功。 5.注册Github账号gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。 注册地址：https://github.com 二，开始搭建博客1.开启Github服务通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 注意：新仓库的名字，最好是 UserName+“github.io”` 的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，可以使用 https://UserName.github.io 访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然点丑)： 2.创建本地博客站点上述的步骤相当于我们使用Github，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很丑。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台(Windows+R+cmd)命令在本地一个合适的位置右键git bash here 输入hexo init blog 创建博客站点文件夹如下： 测试本地博客站点，进入blog文件夹（此即为本地博客根目录）右键git bash here： 12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动本地服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下: 3.同步Github，允许公共访问 初次安装git需要配置用户名和邮箱，否则git会提示： please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： 12$ git config --global user.name &quot;name&quot;$ git config --global user.email &quot;email&quot; 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱 4.Git配置ssh key在博客站点右键Git bash here 输入$ ssh-keygen -t rsa -C &quot;youremail&quot; 第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件： id_rsa和id_rsa.pub。 记事本打开/C/Users/Administrator/.ssh/id_rsa.pub文件 复制该段信息；登录github账户，点击头像进入 Settings -&gt; SSH and GPG keys -&gt; New SSH key 将复制的信息粘贴到该处。 测试是否成功 $ssh -T git@github.com 提示 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 说明添加成功。 5.部署博客在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。首先找到我们的博客仓库，并拷贝仓库地址： 注意：只需复制用户名之后字段 然后修改本地博客目录的配置：修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 注意空格和单词不可以打错 之后执行Git bash here命令： 12npm install hexo-deployer-git //安装部署插件hexo d //部署到github 再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三，发布博客1.发布可以发布自己的第一篇博客了。来尝试一下以下的步骤：在本地博客文件夹根目录(git bash here)输入： 123hexo new &quot;我个人博客的第一篇博客&quot; hexo g //生成网页 hexo d //部署到远端(github) 生成的博客md文件会存放在blog\\source\\_posts文件夹内。 现在打开我们的博客网站： http://UserName.github.io 会看到网页 （显示可能有延迟 所以可以采用以下方法(git bash)： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到服务器 可以用hexo s先查看本地情况再部署到服务器 2.Markdown写作语法推荐使用Typora 1234567891011121314151617181920212223242526272829303132333435363738394041# 写作介绍## 1，字体介绍*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~## 2，分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题## 3，超链接写法：## 4,列表无序列表：写法：* 无序列表项1+ 无序列表项2- 无序列表项3有序列表：写法：1.有序列表项12.有序列表项23.有序列表项3## 5，插入图片在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入：![](url)## 6，表格| 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐| 四，更换主题为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面）。这里以使用github上的next主题为例 1.下载主题切换到本地博客根目录下(git bash here)输入 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在thems里了如下： 2.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next 然后在控制台（git bash）下输入如下命令 123hexo clean //清理缓存hexo g //重新生成博客代码 hexo d //部署到服务器 再次打开我们的博客网站https://UserName.github.io，将会看到更换的主题 主题美化后续更新……","categories":[],"tags":[{"name":"Hexo搭建微博","slug":"Hexo搭建微博","permalink":"http://yoursite.com/tags/Hexo搭建微博/"}]}]}