{"meta":{"title":"个人博客","subtitle":null,"description":null,"author":"Unique","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"从输入URL到页面呈现发生了什么？","slug":"从输入URL到页面呈现发生了什么？","date":"2019-08-22T04:51:17.000Z","updated":"2019-08-22T04:52:40.499Z","comments":true,"path":"passages/从输入URL到页面呈现发生了什么？/","link":"","permalink":"http://yoursite.com/passages/从输入URL到页面呈现发生了什么？/","excerpt":"","text":"从用户输入URL开始，到页面呈现在眼前，这其中发生了什么？总体来说分为以下几个过程: DNS解析 TCP连接 发送HTTP请求 服务器处理请求并返回HTTP报文 浏览器解析渲染页面 连接结束 具体过程DNS解析DNS解析的过程就是寻找哪台机器上有你需要资源的过程。当你在浏览器中输入一个地址时，例如www.baidu.com，其实不是百度网站真正意义上的地址。互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析。它实际上充当了一个翻译的角色，实现了网址到IP地址的转换。网址到IP地址转换的过程是如何进行的? 解析过程DNS解析是一个递归查询的过程。 上述图片是查找www.google.com的IP地址过程。首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。从上述过程中，可以看出网址的解析是一个从右向左的过程: com -&gt; google.com -&gt; www.google.com。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.google.com.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .com -&gt; google.com. -&gt; www.google.com.。 DNS优化了解了DNS的过程，可以为我们带来哪些？上文中请求到google的IP地址时，经历了8个步骤，这个过程中存在多个请求(同时存在UDP和TCP请求，为什么有两种请求方式，请自行查找)。如果每次都经过这么多步骤，是否太耗时间？如何减少该过程的步骤呢？那就是DNS缓存。 DNS缓存DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 在你的chrome浏览器中输入:chrome://dns/，你可以看到chrome浏览器的DNS缓存。 系统缓存主要存在/etc/hosts(Linux系统)中: DNS负载均衡不知道大家有没有思考过一个问题: DNS返回的IP地址是否每次都一样？如果每次都一样是否说明你请求的资源都位于同一台机器上面，那么这台机器需要多高的性能和储存才能满足亿万请求呢？其实真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。在这里打个免费的广告，我平时使用的比较多的是七牛云的CDN(免费)储存图片，作为我个人博客的图床使用。 TCP连接HTTP协议是使用TCP作为其传输层协议的，当TCP出现瓶颈时，HTTP也会受到影响。但由于TCP优化这一块我平常接触的并不是很多，再加上大学时的计算机网络的基础基本上忘完，所以这一部分我也就不在这里分析了。 HTTPS协议我不知道把HTTPS放在这个部分是否合适，但是放在这里好像又说的过去。HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。但是这个过程中存在一定的风险，HTTP报文是明文，如果中间被截取的话会存在一些信息泄露的风险。那么在进入TCP报文之前对HTTP做一次加密就可以解决这个问题了。HTTPS协议的本质就是HTTP + SSL(or TLS)。在HTTP报文进入TCP报文之前，先使用SSL对HTTP报文进行加密。从网络的层级结构看它位于HTTP协议与TCP协议之间。 HTTPS过程HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。具体过程请参考经典的阮一峰先生的博客TLS/SSL握手过程。HTTPS相比于HTTP，虽然提供了安全保证，但是势必会带来一些时间上的损耗，如握手和加密等过程，是否使用HTTPS需要根据具体情况在安全和性能方面做出权衡。 HTTP请求其实这部分又可以称为前端工程师眼中的HTTP，它主要发生在客户端。发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 请求行格式如下: Method Request-URL HTTP-VersionCRLF 1eg: GET index.html HTTP/1.1 常用的方法有: GET, POST, PUT, DELETE, OPTIONS, HEAD。 TODO： 请求报头请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。PS: 客户端不一定特指浏览器，有时候也可使用Linux下的CURL命令以及HTTP客户端测试工具等。常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent等。 请求正文当使用POST, PUT等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的Web应用通常采用Rest架构，请求的数据格式一般为json。这时就需要设置Content-Type: application/json。 服务器处理请求并返回HTTP报文自然而然这部分对应的就是后端工程师眼中的HTTP。后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。这一部分工作一般是由Web服务器去进行，我使用过的Web服务器有Tomcat, Jetty和Netty等等。 HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。 状态码状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。 5xx：服务器端错误–服务器未能实现合法的请求。平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500(分别表示什么请自行查找)。 TODO: 该图是本公司对状态码的一个总结，绘制而成的status code map，请大家参考。 响应报头常见的响应报头字段有: Server, Connection…。 响应报文服务器返回给浏览器的文本信息，通常HTML, CSS, JS, 图片等文件就放在这一部分。 浏览器解析渲染页面浏览器在收到HTML,CSS,JS文件后，它是如何把页面呈现到屏幕上的？下图对应的就是WebKit渲染的过程。 浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 JS的解析是由浏览器中的JS解析引擎完成的。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。 浏览器在解析过程中，如果遇到请求外部资源时，如图像,iconfont,JS等。浏览器将重复1-6过程下载该资源。请求过程是异步的，并不会影响HTML文档进行加载，但是当文档加载过程中遇到JS文件，HTML文档会挂起渲染过程，不仅要等到文档中JS文件加载完毕还要等待解析执行完毕，才会继续HTML的渲染过程。原因是因为JS有可能修改DOM结构，这就意味着JS执行完成前，后续所有资源的下载是没有必要的，这就是JS阻塞后续资源下载的根本原因。CSS文件的加载不影响JS文件的加载，但是却影响JS文件的执行。JS代码执行前浏览器必须保证CSS文件已经下载并加载完毕。 Web优化上面部分主要介绍了一次完整的请求对应的过程，了解该过程的目的无非就是为了Web优化。在谈到Web优化之前，我们回到一个更原始的问题，Web前端的本质是什么。我的理解是: 将信息快速并友好的展示给用户并能够与用户进行交互。快速的意思就是在尽可能短的时间内完成页面的加载，试想一下当你在淘宝购买东西的时候，淘宝页面加载了10几秒才显示出物品，这个时候你还有心情去购买吗？怎么快速的完成页面的加载呢？优雅的学院派雅虎给出了常用的一些手段，也就是我们熟悉的雅虎34条军规。这34军规实际上就是围绕请求过程进行的一些优化方式。 如何尽快的加载资源？答案就是能不从网络中加载的资源就不从网络中加载，当我们合理使用缓存，将资源放在浏览器端，这是最快的方式。如果资源必须从网络中加载，则要考虑缩短连接时间，即DNS优化部分;减少响应内容大小，即对内容进行压缩。另一方面，如果加载的资源数比较少的话，也可以快速的响应用户。当资源到达浏览器之后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow，所以围绕这一部分就是考虑如何减少reflow的次数。","categories":[],"tags":[]},{"title":"JS中的this指向","slug":"JS中的this指向","date":"2019-08-21T04:42:09.000Z","updated":"2019-08-21T04:43:45.453Z","comments":true,"path":"passages/JS中的this指向/","link":"","permalink":"http://yoursite.com/passages/JS中的this指向/","excerpt":"","text":"首先，必须搞清楚在JS里面，函数的几种调用方式: 普通函数调用 作为方法来调用 作为构造函数来调用 使用apply/call方法来调用 Function.prototype.bind方法 es6箭头函数 但是不管函数是按哪种方法来调用的，请记住一点：谁调用这个函数或方法,this关键字就指向谁。 接下来就分情况来讨论下这些不同的情况： 普通函数调用123456781 function person()&#123;2 this.name=\"xl\";3 console.log(this);4 console.log(this.name);5 &#125;6 7 person(); //输出 window xl 8 在这段代码中person函数作为普通函数调用，实际上person是作为全局对象window的一个方法来进行调用的,即window.person();所以这个地方是window对象调用了person方法,那么person函数当中的this即指window,同时window还拥有了另外一个属性name,值为xl. 123451 var name=\"xl\";2 function person()&#123;3 console.log(this.name);4 &#125;5 person(); //输出 xl 同样这个地方person作为window的方法来调用，在代码的一开始定义了一个全局变量name，值为xl,它相当于window的一个属性,即window.name=&quot;xl&quot;,又因为在调用person的时候this是指向window的，因此这里会输出xl. 作为方法来调用在上面的代码中，普通函数的调用即是作为window对象的方法进行调用。显然this关键字指向了window对象. 再来看下其他的形式 12345678910111213 var name=\"XL\"; var person=&#123; name:\"xl\", showName:function()&#123; console.log(this.name); &#125; &#125; person.showName(); //输出 xl//这里是person对象调用showName方法，很显然this关键字是指向person对象的，所以会输出name var showNameA=person.showName; showNameA(); //输出 XL //这里将person.showName方法赋给showNameA变量，此时showNameA变量相当于window对象的一个属性，因此showNameA()执行的时候相当于window.showNameA(),即window对象调用showNameA这个方法，所以this关键字指向window 再换种形式： 12345678910111213var personA=&#123; name:\"xl\", showName:function()&#123; console.log(this.name); &#125;&#125;var personB=&#123; name:\"XL\", sayName:personA.showName&#125;personB.sayName(); //输出 XL//虽然showName方法是在personA这个对象中定义，但是调用的时候却是在personB这个对象中调用，因此this对象指向 作为构造函数来调用1234567891011 1 function Person(name)&#123; 2 this.name=name; 3 &#125; 4 var personA=Person(\"xl\"); 5 console.log(personA.name); // 输出 undefined 6 console.log(window.name);//输出 xl 7 //上面代码没有进行new操作，相当于window对象调用Person(\"xl\")方法，那么this指向window对象，并进行赋值操作window.name=\"xl\". 8 9 var personB=new Person(\"xl\");10 console.log(personB.name);// 输出 xl11 //这部分代码的解释见下 new操作符12345678910//下面这段代码模拟了new操作符(实例化对象)的内部过程 function person(name)&#123; var o=&#123;&#125;; o.__proto__=Person.prototype; //原型继承 Person.call(o,name); return o; &#125; var personB=person(\"xl\"); console.log(personB.name); // 输出 xl ​ 这段代码涉及到了proto及prototype的概念，如果有需要了解，请点击链接 在person里面首先创建一个空对象o，将o的proto指向Person.prototype完成对原型的属性和方法的继承 Person.call(o,name)这里即函数Person作为apply/call调用(具体内容下方)，将Person对象里的this改为o，即完成了o.name=name操作 返回对象o。 12因此`person(\"xl\")`返回了一个继承了`Person.prototype`对象上的属性和方法，以及拥有`name`属性为\"xl\"的对象，并将它赋给变量`personB`.所以`console.log(personB.name)`会输出\"xl\" call/apply方法的调用在JS里函数也是对象，因此函数也有方法。从Function.prototype上继承到Function.prototype.call/Function.prototype.apply方法call/apply方法最大的作用就是能改变this关键字的指向. 1Obj.method.apply(AnotherObj,arguments); 12345678910111213141516171819202122232425262728 1 var name=\"XL\"; 2 var Person=&#123; 3 name:\"xl\", 4 showName:function()&#123; 5 console.log(this.name); 6 &#125; 7 &#125; 8 Person.showName.call(); //输出 \"XL\" 9 //这里call方法里面的第一个参数为空，默认指向window。10 //虽然showName方法定义在Person对象里面，但是使用call方法后，将showName方法里面的this指向了window。因此最后会输出\"XL\";11 funtion FruitA(n1,n2)&#123;12 this.n1=n1;13 this.n2=n2;14 this.change=function(x,y)&#123;15 this.n1=x;16 this.n2=y;17 &#125;18 &#125;19 20 var fruitA=new FruitA(\"cheery\",\"banana\");21 var FruitB=&#123;22 n1:\"apple\",23 n2:\"orange\"24 &#125;;25 fruitA.change.call(FruitB,\"pear\",\"peach\");26 27 console.log(FruitB.n1); //输出 pear28 console.log(FruitB.n2);// 输出 peach FruitB调用fruitA的change方法，将fruitA中的this绑定到对象FruitB上。 Function.prototype.bind()方法123456789101112var name=\"XL\";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log(\"my name is \"+this.name); &#125;,50) &#125;&#125;var person=new Person(\"xl\");person.sayName() //输出 “my name is XL”; //这里的setTimeout()定时函数,相当于window.setTimeout(),由window这个全局对象对调用,因此this的指向为window, 则this.name则为XL 那么如何才能输出&quot;my name is xl&quot;呢？ 1234567891011var name=\"XL\";function Person(name)&#123; this.name=name; this.sayName=function()&#123; setTimeout(function()&#123; console.log(\"my name is \"+this.name); &#125;.bind(this),50) //注意这个地方使用的bind()方法，绑定setTimeout里面的匿名函数的this一直指向Person对象 &#125;&#125;var person=new Person(\"xl\");person.sayName(); //输出 “my name is xl”; 这里setTimeout(function(){console.log(this.name)}.bind(this),50);,匿名函数使用bind(this)方法后创建了新的函数，这个新的函数不管在什么地方执行，this都指向的Person,而非window,因此最后的输出为”my name is xl”而不是”my name is XL” 另外几个需要注意的地方：setTimeout/setInterval/匿名函数执行的时候，this默认指向window对象，除非手动改变this的指向。在《javascript高级程序设计》当中，写到：“超时调用的代码(setTimeout)都是在全局作用域中执行的，因此函数中的this的值，在非严格模式下是指向window对象，在严格模式下是指向undefined”。本文都是在非严格模式下的情况。 123456789101112var name=\"XL\"; function Person()&#123; this.name=\"xl\"; this.showName=function()&#123; console.log(this.name); &#125; setTimeout(this.showName,50); &#125; var person=new Person(); //输出 \"XL\" //在setTimeout(this.showName,50)语句中，会延时执行this.showName方法 //this.showName方法即构造函数Person()里面定义的方法。50ms后，执行this.showName方法，this.showName里面的this此时便指向了window对象。则会输出\"XL\"; 修改上面的代码： 1234567891011121314 1 var name=\"XL\"; 2 function Person()&#123; 3 this.name=\"xl\"; 4 var that=this; 5 this.showName=function()&#123; 6 console.log(that.name); 7 &#125; 8 setTimeout(this.showName,50) 9 &#125;10 var person=new Person(); //输出 \"xl\"11 12 13 14 //这里在Person函数当中将this赋值给that，即让that保存Person对象，因此在setTimeout(this.showName,50)执行过程当中，console.log(that.name)即会输出Person对象的属性\"xl\" 匿名函数： 12345678910111213141516171819202122232425262728 1 var name=\"XL\"; 2 var person=&#123; 3 name:\"xl\", 4 showName:function()&#123; 5 console.log(this.name); 6 &#125; 7 sayName:function()&#123; 8 (function(callback)&#123; 9 callback();10 &#125;)(this.showName)11 &#125;12 &#125;13 person.sayName(); //输出 XL14 var name=\"XL\";15 var person=&#123;16 name:\"xl\",17 showName:function()&#123;18 console.log(this.name);19 &#125;20 sayName:function()&#123;21 var that=this;22 (function(callback)&#123;23 callback();24 &#125;)(that.showName)25 &#125;26 &#125;27 person.sayName() ; //输出 \"xl\"28 //匿名函数的执行同样在默认情况下this是指向window的，除非手动改变this的绑定对象 Eval函数该函数执行的时候，this绑定到当前作用域的对象上 123456789101112var name=\"XL\";var person=&#123; name:\"xl\", showName:function()&#123; eval(\"console.log(this.name)\"); &#125;&#125;person.showName(); //输出 \"xl\"var a=person.showName;a(); //输出 \"XL\" 箭头函数es6里面this指向固定化，始终指向外部对象，因为箭头函数没有this,因此它自身不能进行new实例化,同时也不能使用call, apply, bind等方法来改变this的指向 1234567891011function Timer() &#123; this.seconds = 0; setInterval( () =&gt; this.seconds ++, 1000); &#125; var timer = new Timer(); setTimeout( () =&gt; console.log(timer.seconds), 3100); // 3// 在构造函数内部的setInterval()内的回调函数，this始终指向实例化的对象，并获取实例化对象的seconds的属性,每1s这个属性的值都会增加1。否则最后在3s后执行setTimeOut()函数执行后输出的是0","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"请求方法总结","slug":"请求方法总结","date":"2019-08-20T04:59:13.000Z","updated":"2019-08-20T05:00:44.601Z","comments":true,"path":"passages/请求方法总结/","link":"","permalink":"http://yoursite.com/passages/请求方法总结/","excerpt":"","text":"XMLHttpRequest XMLHttpRequest是最早出现的与服务器交换数据的方案，有了XMLHttpRequest，开发者终于可以在不重新加载页面的情况下更新网页，可以在页面加载后请求接受以及发送数据。而所有浏览器均可以获取XMLHttpRequest对象： 1var xhr = new XMLHttpRequest(); //获取xhr对象 但是XMLHttpRequest是个比较粗燥的底层对象，各个浏览器对其的创建方法也不同，以下是兼容方法： 1234567891011121314var xhr;if (window.XMLHttpRequest) &#123; // Mozilla, Safari... xhr = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); //IE5,6 &#125; catch (e) &#123;&#125; &#125;&#125; 使用XMLHttpRequest发起一个get请求 12//get请求xhr.open(\"GET\",\"test1.txt\",true);xhr.send(); 完整的post请求代码如下： 123456789101112131415161718192021222324252627282930var xhr;if (window.XMLHttpRequest) &#123; // Mozilla, Safari... xhr = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; // IE try &#123; xhr = new ActiveXObject('Msxml2.XMLHTTP'); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject('Microsoft.XMLHTTP'); &#125; catch (e) &#123; &#125; &#125;&#125;if (xhr) &#123; xhr.onreadystatechange = onReadyStateChange; xhr.open('POST', '/api', true); // 设置 Content-Type 为 application/x-www-form-urlencoded // 以表单的形式传递数据 xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('username=admin&amp;password=root');&#125;// onreadystatechange 方法function onReadyStateChange() &#123; // 该函数会被调用四次 if (xhr.readyState === 4 &amp;&amp;xhr.status === 200) &#123; console.log('执行成功'); &#125; else &#123; console.log('执行出错'); &#125;&#125; Jquery Ajax 说到Jquery，这是一个时代，几乎统治了前端10年有余，彻底解决了UI层与数据层交互的问题，直到三大框架(Angular/React/Vue）的出现，前端进入MVVM浪潮。而Ajax将XHR进行封装，让开发者可以更加便捷方便进行使用。 1234567891011121314$.ajax(&#123; //标准写法 type: 'POST', url: url, data: data, dataType: dataType, success: function () &#123;&#125;, error: function () &#123;&#125;&#125;);$.get(url,function()&#123;&#125;); //get请求$.post(url,body,function()&#123;&#125;);//post请求$.getJSON(url,function()&#123;&#125;); //get请求从服务器加载Json编码 优点： 对原生XHR的封装 针对MVC的编程 完美的兼容性 支持jsonp 缺点： 不符合MVVM 异步模型不够现代，不支持链式，代码可读性差 整个Jquery太大，引入成本过高 Fetch fetch其实是一个新世界，脱离的XHR，完全是基于Promise的异步处理机制，使用起来会比起ajax更加简单。 使用fetch的代码会相比xhr来说更具有条理性 123456fetch(url).then(function(response) &#123; return response.json();&#125;).then(function(data) &#123; console.log(data);&#125;).catch(function(e) &#123; console.log(\"Oops, error\");&#125;); 在使用ES6的箭头函数后 123fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(\"Oops, error\", e)) 优点： 更加底层，提供的API丰富（request, response） 语法简单，脱离了XHR，基于ES新的Promise设计 看到以上，或许你会觉得fetch真的很美好，但是请了解，fetch本身是一个 low-level 的 API，它注定不会像你习惯的 $.ajax 或是 axios 等库帮你封装各种各样的功能或实现。 所以它是存在一定的缺点： 兼容性比较凄惨，低级别浏览器均不支持，需要实现fetch的polyfill了。思路其实很简单，就是判断浏览器是否支持原生的fetch，不支持的话，就仍然使用XMLHttpRequest的方式实现，同时结合Promise来进行封装。常见的polyfill就有：es6-promise,babel-polyfill,fetch-ie8等 不支持jsonp，可以引入fetch-jsonp `javascript //安装 npm install fetch-jsonp –save-dev 1234567891011//使用 fetchJsonp(url, &#123; timeout: 3000, jsonpCallback: 'callback' &#125;) .then(function(response) &#123; console.log(response.json());&#125;) .catch(function(e) &#123; console.log(e) &#125;); 没有拦截器，需要额外再封装一层或者fetch-interceptor- 默认不带cookie，需要添加配置 123javascriptfetch(url,&#123; credentials: 'include' //include表示cookie既可同域，也可跨域，‘same-origin’表示只可同域&#125;); 没有abort，不支持timeout超时处理 可以用Promise.race()实现，Promise.race(iterable) 方法返回一个Promise对象，只要 iterable 中任意一个Promise 被 resolve 或者 reject 后，外部的Promise 就会以相同的值被 resolve 或者 reject。 无法获取progress状态 fetch中的Response.body 中实现了getReader()方法用于读取原始字节流, 该字节流可以循环读取。参考： https://stackoverflow.com/questions/35711724/upload-progress-indicators-for-fetch https://jakearchibald.com/2016/streams-ftw/ Axios axios也是比较新的网络请求的类库，并且被尤雨溪尤大推荐，已成为VUE的网络请求标配，也是十分的火爆。它本身也是对原生XHR的封装。 支持node，创建http请求 支持Promise API 客户端防止CSRF：每个请求带一个cookie拿到的key 拦截请求和响应 可取消请求 兼容性上虽然axios本质上也是对原生XHR的封装，但是它也依赖原生ES6 Promise的实现，和fetch一样需要polyfill的兼容。 安装 12//npmnpm install axios//cdn&lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt; 基本使用如下： 12345678910111213141516171819202122232425262728axios(&#123; method: 'GET', url: url,&#125;) .then(res =&gt; &#123; console.log(res)&#125;) .catch(err =&gt; &#123; console.log(err)&#125;)// get请求axios.get(url) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;);// post请求axios.post(‘/user’, &#123; name: 'Jerry', lastName: 'Liang' &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 特殊场景的处理 在开发过程中，经常会遇到比较尴尬的场景就是多请求的串行与并发，并发比较容易解决，不存在回调地狱，但是代码可读性就会容易变得很渣，而串行问题对于前端是绝望的，最好的办法是后端来做合并，如果后端不做这块的处理，前端就必须来面对回调地狱。 多请求串行123456789101112131415161718192021222324// ajax$.ajax(&#123; url: '', data: '', success: function (data) &#123; $.ajax(&#123; url: '', data: '', success: function (data ) &#123; $.ajax(&#123; // 如此一层嵌套一层 &#125;) &#125; &#125;) &#125;&#125;)//axiosaxios.get(url).then(res =&gt; &#123; return axios.get(url,&#123; &#123;name:result.name&#125; &#125;);&#125;).then(res =&gt; &#123; //如此一层层嵌套&#125;); 多请求并行12345678910111213141516171819202122232425262728293031323334353637//ajax 通过计数器实现（虽然Jquery支持$.when的方式，但此处不做案例）var num = 0;function all()&#123; num++; if(n&gt;=3)console.log('三个请求全部完成')；&#125;$.ajax(&#123; url: '', data: '', success: function (data) &#123; console.log(\"ajax请求1 完成\"); all(); &#125;&#125;)$.ajax(&#123; url: '', data: '', success: function (data) &#123; console.log(\"ajax请求2 完成\"); all(); &#125;&#125;)$.ajax(&#123; url: '', data: '', success: function (data) &#123; console.log(\"ajax请求3 完成\"); all(); &#125;&#125;)//axiosfunction getInfo() &#123; return axios.get(url);&#125;function getUser() &#123; return axios.get(url);&#125;axios.all([getInfo(), getUser()]) .then(axios.spread(function (info, user) &#123; // 两个请求现在都执行完成 &#125;));","categories":[],"tags":[]},{"title":"vue性能优化","slug":"vue性能优化","date":"2019-08-19T13:03:01.000Z","updated":"2019-08-19T13:06:21.691Z","comments":true,"path":"passages/vue性能优化/","link":"","permalink":"http://yoursite.com/passages/vue性能优化/","excerpt":"","text":"VUE的性能优化主要分为三部分： Vue代码层面的优化 webpack配置层面优化 基础Web技术层面优化 一、代码层面的优化1.1、v-if 和 v-show 区分使用场景v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。 所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。 1.2、computed 和 watch 区分使用场景computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值； watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作； 运用场景： 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算； 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if（1）v-for 遍历必须为 item 添加 key 在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。 （2）v-for 遍历避免同时使用 v-if v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。 推荐： 123456789101112&lt;ul&gt; &lt;li v-for=&quot;user in activeUsers&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt;computed: &#123; activeUsers: function () &#123; return this.users.filter(function (user) &#123; return user.isActive &#125;) &#125;&#125; 不推荐： 12345678&lt;ul&gt; &lt;li v-for=&quot;user in users&quot; v-if=&quot;user.isActive&quot; :key=&quot;user.id&quot;&gt; &#123;&#123; user.name &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 1.4、长列表性能优化Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。 12345678export default &#123; data: () =&gt; (&#123; users: &#123;&#125; &#125;), async created() &#123; const users = await axios.get(\"/api/users\"); this.users = Object.freeze(users); &#125;&#125;; 1.5、事件的销毁Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内使用 addEventListene 等方式是不会自动销毁的，我们需要在组件销毁时手动移除这些事件的监听，以免造成内存泄露，如： 123456created() &#123; addEventListener('click', this.click, false)&#125;,beforeDestroy() &#123; removeEventListener('click', this.click, false)&#125; 1.6、图片资源懒加载对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件： （1）安装插件 1npm install vue-lazyload --save-dev （2）在入口文件 man.js 中引入并使用 1import VueLazyload from &apos;vue-lazyload&apos; 然后再 vue 中直接使用 1Vue.use(VueLazyload) 或者添加自定义选项 123456Vue.use(VueLazyload, &#123; preLoad: 1.3, error: 'dist/error.png', loading: 'dist/loading.gif', attempt: 1&#125;) （3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示： 1&lt;img v-lazy=&quot;/static/img/1.png&quot;&gt; 以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。 1.7、路由懒加载Vue 是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。 路由懒加载： 123456const Foo = () =&gt; import('./Foo.vue')const router = new VueRouter(&#123; routes: [ &#123; path: '/foo', component: Foo &#125; ]&#125;) 1.8、第三方插件的按需引入我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例： （1）首先，安装 babel-plugin-component ： 1npm install babel-plugin-component -D （2）然后，将 .babelrc 修改为： 123456789101112&#123; \"presets\": [[\"es2015\", &#123; \"modules\": false &#125;]], \"plugins\": [ [ \"component\", &#123; \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" &#125; ] ]&#125; （3）在 main.js 中引入部分组件： 1234import Vue from 'vue';import &#123; Button, Select &#125; from 'element-ui'; Vue.use(Button) Vue.use(Select) 1.9、优化无限列表性能如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller 来优化这种无限列表的场景的。 1.10、服务端渲染 SSR or 预渲染服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。 （1）服务端渲染的优点： 更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面； 更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间； （2）服务端渲染的缺点： 更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境； 更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。 如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如 /， /about， /contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。 二、Webpack 层面的优化2.1、Webpack 对图片进行压缩在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片： （1）首先，安装 image-webpack-loader ： 1npm install image-webpack-loader --save-dev （2）然后，在 webpack.base.conf.js 中进行配置： 123456789101112131415161718&#123; test: /\\.(png|jpe?g|gif|svg)(\\?.*)?$/, use:[ &#123; loader: 'url-loader', options: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; loader: 'image-webpack-loader', options: &#123; bypassOnDebug: true, &#125; &#125; ]&#125; 2.2、减少 ES6 转为 ES5 的冗余代码Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码： 1class HelloWebpack extends Component&#123;...&#125; 这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数 1babel-runtime/helpers/createClass // 用于实现 class 语法babel-runtime/helpers/inherits // 用于实现 extends 语法 在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(&#39;babel-runtime/helpers/createClass&#39;) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。 （1）首先，安装 babel-plugin-transform-runtime ： 1npm install babel-plugin-transform-runtime --save-dev （2）然后，修改 .babelrc 配置文件为： 1&quot;plugins&quot;: [ &quot;transform-runtime&quot;] 如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。 2.3、提取公共代码如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题： 相同的资源被重复加载，浪费用户的流量和服务器的成本。 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下： 1234567891011121314151617// 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function(module, count) &#123; return ( module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ); &#125;&#125;), // 抽取出代码模块的映射关系 new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor']&#125;) 如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。 2.4、模板预编译当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。 预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。 如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。 2.5、提取组件的 CSS当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。 查阅这个构建工具各自的文档来了解更多： webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好) Browserify + vueify Rollup + rollup-plugin-vue 2.6、优化 SourceMap我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。 SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ） 开发环境推荐：cheap-module-eval-source-map 生产环境推荐：cheap-module-source-map 原因如下： cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息； module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置； soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性； eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。 2.7、构建结果输出分析Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。 我们在项目中 webpack.prod.conf.js 进行配置 1234if (config.build.bundleAnalyzerReport) &#123; var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin; webpackConfig.plugins.push(new BundleAnalyzerPlugin());&#125; 执行 $ npm run build --report 后生成分析报告如下： 2.8、Vue 项目的编译优化如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》 三、基础的 Web 技术优化3.1、开启 gzip 压缩gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右 以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下： 安装： 1npm install compression --save 添加代码逻辑： 1var compression = require('compression');var app = express();app.use(compression()) 重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ： 3.2、浏览器缓存为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。 3.3、CDN 的使用浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。 3.4、使用 Chrome Performance 查找性能瓶颈Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。 打开 Chrome 开发者工具，切换到 Performance 面板 点击 Record 开始录制 刷新页面或展开某个节点 点击 Stop 停止录制","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"JS常用公具","slug":"JS常用公具","date":"2019-08-19T09:22:35.000Z","updated":"2019-08-19T09:24:59.669Z","comments":true,"path":"passages/JS常用公具/","link":"","permalink":"http://yoursite.com/passages/JS常用公具/","excerpt":"","text":"1、isStatic： 检测数据是不是除了symbol外的原始数据 12345678function isStatic(value) &#123; return( typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean' || typeof value === 'undefined' || value === null )&#125; 2、isPrimitive： 检测数据是不是原始数据123function isPrimitive(value) &#123; return isStatic(value) || typeof value === 'symbol'&#125; 3、isObject： 判断数据是不是引用类型的数据 (例如： arrays, functions, objects, regexes, new Number(0),以及 new String(‘’))1234function isObject(value) &#123; let type = typeof value; return value != null &amp;&amp; (type == 'object' || type == 'function');&#125; 4、isObjectLike： 检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 “object”123function isObjectLike(value) &#123; return value != null &amp;&amp; typeof value == 'object';&#125; 5、getRawType： 获取数据类型，返回结果为 Number、String、Object、Array等1234function getRawType(value) &#123; return Object.prototype.toString.call(value).slice(8, -1)&#125;//getoRawType([]) ==&gt; Array 6、isPlainObject： 判断数据是不是Object类型的数据123function isPlainObject(obj) &#123; return Object.prototype.toString.call(obj) === '[object Object]'&#125; 7、isArray： 判断数据是不是数组类型的数据123function isArray(arr) &#123; return Object.prototype.toString.call(arr) === '[object Array]'&#125; 将isArray挂载到Array上 1Array.isArray = Array.isArray || isArray; 8、isRegExp： 判断数据是不是正则对象123function isRegExp(value) &#123; return Object.prototype.toString.call(value) === '[object RegExp]'&#125; 9、isDate： 判断数据是不是时间对象123function isDate(value) &#123; return Object.prototype.toString.call(value) === '[object Date]'&#125; 10、isNative： 判断 value 是不是浏览器内置函数内置函数toString后的主体代码块为 [native code] ，而非内置函数则为相关代码，所以非内置函数可以进行拷贝(toString后掐头去尾再由Function转) 123function isNative(value) &#123; return typeof value === 'function' &amp;&amp; /native code/.test(value.toString())&#125; 11、isFunction： 检查 value 是不是函数123function isFunction(value) &#123; return Object.prototype.toString.call(value) === '[object Function]'&#125; 12、isLength： 检查 value 是否为有效的类数组长度123function isLength(value) &#123; return typeof value == 'number' &amp;&amp; value &gt; -1 &amp;&amp; value % 1 == 0 &amp;&amp; value &lt;= Number.MAX_SAFE_INTEGER;&#125; 13、isArrayLike： 检查 value 是否是类数组如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。这里字符串也将被当作类数组。 123function isArrayLike(value) &#123; return value != null &amp;&amp; isLength(value.length) &amp;&amp; !isFunction(value);&#125; 14、isEmpty： 检查 value 是否为空如果是null，直接返回true；如果是类数组，判断数据长度；如果是Object对象，判断是否具有属性；如果是其他数据，直接返回false(也可改为返回true) 123456789101112131415function isEmpty(value) &#123; if (value == null) &#123; return true; &#125; if (isArrayLike(value)) &#123; return !value.length; &#125;else if(isPlainObject(value))&#123; for (let key in value) &#123; if (hasOwnProperty.call(value, key)) &#123; return false; &#125; &#125; &#125; return false;&#125; 15、cached： 记忆函数：**缓存函数的运算结果**123456function cached(fn) &#123; let cache = Object.create(null); return function cachedFn(str) &#123; let hit = cache[str]; return hit || (cache[str] = fn(str)) &#125;&#125; 16、camelize： 横线转驼峰命名1234let camelizeRE = /-(w)/g;function camelize(str) &#123; return str.replace(camelizeRE, function(_, c) &#123; return c ? c.toUpperCase() : ''; &#125;)&#125;//ab-cd-ef ==&gt; abCdEf//使用记忆函数let _camelize = cached(camelize) 17、hyphenate： 驼峰命名转横线命名： 拆分字符串，使用 - 相连，并且转换为小写1234let hyphenateRE = /B([A-Z])/g;function hyphenate(str)&#123; return str.replace(hyphenateRE, '-$1').toLowerCase()&#125;//abCd ==&gt; ab-cd//使用记忆函数let _hyphenate = cached(hyphenate); 18、capitalize： 字符串首位大写1234function capitalize(str)&#123; return str.charAt(0).toUpperCase() + str.slice(1)&#125;// abc ==&gt; Abc//使用记忆函数let _capitalize = cached(capitalize) 19、extend： 将属性混合到目标对象中123456function extend(to, _from) &#123; for(let key in _from) &#123; to[key] = _from[key]; &#125; return to&#125; 20、Object.assign： 对象属性复制，浅拷贝123456789101112Object.assign = Object.assign || function()&#123; if(arguments.length == 0) throw new TypeError('Cannot convert undefined or null to object'); let target = arguments[0], args = Array.prototype.slice.call(arguments, 1), key args.forEach(function(item)&#123; for(key in item)&#123; item.hasOwnProperty(key) &amp;&amp; ( target[key] = item[key] ) &#125; &#125;) return target&#125; 使用Object.assign可以浅克隆一个对象： 1let clone = Object.assign(&#123;&#125;, target) 简单的深克隆可以使用JSON.parse()和JSON.stringify()，这两个api是解析json数据的，所以只能解析除symbol外的原始类型及数组和对象 1let clone = JSON.parse( JSON.stringify(target) ) 21、clone： 克隆数据，可深度克隆这里列出了原始类型，时间、正则、错误、数组、对象的克隆规则，其他的可自行补充 1234567891011121314151617181920212223function clone(value, deep)&#123; if(isPrimitive(value))&#123; return value &#125; if (isArrayLike(value)) &#123; //是类数组 alue = Array.prototype.slice.call(value) return value.map(item =&gt; deep ? clone(item, deep) : item) &#125;else if(isPlainObject(value))&#123; //是对象 let target = &#123;&#125;, key; for (key in value) &#123; value.hasOwnProperty(key) &amp;&amp; ( target[key] = deep ? clone(value[key], deep) : value[key] ) &#125; &#125; let type = getRawType(value) switch(type)&#123; case 'Date': case 'RegExp': case 'Error': value = new window[type](value); break; &#125; return value&#125; 22、识别各种浏览器及平台123456789101112//运行环境是浏览器let inBrowser = typeof window !== 'undefined';//运行环境是微信let inWeex = typeof WXEnvironment !== 'undefined' &amp;&amp; !!WXEnvironment.platform;let weexPlatform = inWeex &amp;&amp; WXEnvironment.platform.toLowerCase();//浏览器 UA 判断let UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();let isIE = UA &amp;&amp; /msie|trident/.test(UA);let isIE9 = UA &amp;&amp; UA.indexOf('msie 9.0') &gt; 0;let isEdge = UA &amp;&amp; UA.indexOf('edge/') &gt; 0;let isAndroid = (UA &amp;&amp; UA.indexOf('android') &gt; 0) || (weexPlatform === 'android');let isIOS = (UA &amp;&amp; /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');let isChrome = UA &amp;&amp; /chrome/d+/.test(UA) &amp;&amp; !isEdge; 23、getExplorerInfo： 获取浏览器信息123456789101112131415161718192021222324252627282930function getExplorerInfo() &#123; let t = navigator.userAgent.toLowerCase(); return 0 &lt;= t.indexOf(\"msie\") ? &#123; //ie &lt; 11 type: \"IE\", version: Number(t.match(/msie ([d]+)/)[1]) &#125; : !!t.match(/trident/.+?rv:(([d.]+))/) ? &#123; // ie 11 type: \"IE\", version: 11 &#125; : 0 &lt;= t.indexOf(\"edge\") ? &#123; type: \"Edge\", version: Number(t.match(/edge/([d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"firefox\") ? &#123; type: \"Firefox\", version: Number(t.match(/firefox/([d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"chrome\") ? &#123; type: \"Chrome\", version: Number(t.match(/chrome/([d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"opera\") ? &#123; type: \"Opera\", version: Number(t.match(/opera.([d]+)/)[1]) &#125; : 0 &lt;= t.indexOf(\"Safari\") ? &#123; type: \"Safari\", version: Number(t.match(/version/([d]+)/)[1]) &#125; : &#123; type: t, version: -1 &#125; &#125; 24、isPCBroswer： 检测是否为PC端浏览器模式123456789101112function isPCBroswer() &#123; let e = navigator.userAgent.toLowerCase() , t = \"ipad\" == e.match(/ipad/i) , i = \"iphone\" == e.match(/iphone/i) , r = \"midp\" == e.match(/midp/i) , n = \"rv:1.2.3.4\" == e.match(/rv:1.2.3.4/i) , a = \"ucweb\" == e.match(/ucweb/i) , o = \"android\" == e.match(/android/i) , s = \"windows ce\" == e.match(/windows ce/i) , l = \"windows mobile\" == e.match(/windows mobile/i); return !(t || i || r || n || a || o || s || l)&#125; 25、unique： 数组去重，返回一个新数组1234567891011121314151617181920212223242526function unique(arr)&#123; if(!isArrayLink(arr))&#123; //不是类数组对象 return arr &#125; let result = [] let objarr = [] let obj = Object.create(null) arr.forEach(item =&gt; &#123; if(isStatic(item))&#123; //是除了symbol外的原始数据 let key = item + '_' + getRawType(item); if(!obj[key])&#123; obj[key] = true result.push(item) &#125; &#125;else&#123; //引用类型及symbol if(!objarr.includes(item))&#123; objarr.push(item) result.push(item) &#125; &#125; &#125;) return resulte&#125; 26、Set简单实现123456789101112131415161718192021222324252627282930313233343536373839window.Set = window.Set || (function () &#123; function Set(arr) &#123; this.items = arr ? unique(arr) : []; this.size = this.items.length; // Array的大小 &#125; Set.prototype = &#123; add: function (value) &#123; // 添加元素,若元素已存在,则跳过，返回 Set 结构本身。 if (!this.has(value)) &#123; this.items.push(value); this.size++; &#125; return this; &#125;, clear: function () &#123; //清除所有成员，没有返回值。 this.items = [] this.size = 0 &#125;, delete: function (value) &#123; //删除某个值，返回一个布尔值，表示删除是否成功。 return this.items.some((v, i) =&gt; &#123; if(v === value)&#123; this.items.splice(i,1) return true &#125; return false &#125;) &#125;, has: function (value) &#123; //返回一个布尔值，表示该值是否为Set的成员。 return this.items.some(v =&gt; v === value) &#125;, values: function () &#123; return this.items &#125;, &#125; return Set;&#125;()); 27、repeat： 生成一个重复的字符串，有n个str组成，可修改为填充为数组等12345678910111213function repeat(str, n) &#123; let res = ''; while(n) &#123; if(n % 2 === 1) &#123; res += str; &#125; if(n &gt; 1) &#123; str += str; &#125; n &gt;&gt;= 1; &#125; return res&#125;;//repeat('123',3) ==&gt; 123123123 ## 28、dateFormater： 格式化时间1234567891011121314151617function dateFormater(formater, t)&#123; let date = t ? new Date(t) : new Date(), Y = date.getFullYear() + '', M = date.getMonth() + 1, D = date.getDate(), H = date.getHours(), m = date.getMinutes(), s = date.getSeconds(); return formater.replace(/YYYY|yyyy/g,Y) .replace(/YY|yy/g,Y.substr(2,2)) .replace(/MM/g,(M&lt;10?'0':'') + M) .replace(/DD/g,(D&lt;10?'0':'') + D) .replace(/HH|hh/g,(H&lt;10?'0':'') + H) .replace(/mm/g,(m&lt;10?'0':'') + m) .replace(/ss/g,(s&lt;10?'0':'') + s)&#125;// dateFormater('YYYY-MM-DD HH:mm', t) ==&gt; 2019-06-26 18:30// dateFormater('YYYYMMDDHHmm', t) ==&gt; 201906261830 29、dateStrForma： 将指定字符串由一种时间格式转化为另一种from的格式应对应str的位置 1234567891011121314151617181920212223function dateStrForma(str, from, to)&#123; //'20190626' 'YYYYMMDD' 'YYYY年MM月DD日' str += '' let Y = '' if(~(Y = from.indexOf('YYYY')))&#123; Y = str.substr(Y, 4) to = to.replace(/YYYY|yyyy/g,Y) &#125;else if(~(Y = from.indexOf('YY')))&#123; Y = str.substr(Y, 2) to = to.replace(/YY|yy/g,Y) &#125; let k,i ['M','D','H','h','m','s'].forEach(s =&gt;&#123; i = from.indexOf(s+s) k = ~i ? str.substr(i, 2) : '' to = to.replace(s+s, k) &#125;) return to&#125;// dateStrForma('20190626', 'YYYYMMDD', 'YYYY年MM月DD日') ==&gt; 2019年06月26日// dateStrForma('121220190626', '----YYYYMMDD', 'YYYY年MM月DD日') ==&gt; 2019年06月26日// dateStrForma('2019年06月26日', 'YYYY年MM月DD日', 'YYYYMMDD') ==&gt; 20190626// 一般的也可以使用正则来实现//'2019年06月26日'.replace(/(d&#123;4&#125;)年(d&#123;2&#125;)月(d&#123;2&#125;)日/, '$1-$2-$3') ==&gt; 2019-06-26 30、getPropByPath：**根据字符串路径获取对象属性 : ‘obj[0].count’**123456789101112131415161718192021222324252627282930function getPropByPath(obj, path, strict) &#123; let tempObj = obj; path = path.replace(/[(w+)]/g, '.$1'); //将[0]转化为.0 path = path.replace(/^./, ''); //去除开头的. let keyArr = path.split('.'); //根据.切割 let i = 0; for (let len = keyArr.length; i &lt; len - 1; ++i) &#123; if (!tempObj &amp;&amp; !strict) break; let key = keyArr[i]; if (key in tempObj) &#123; tempObj = tempObj[key]; &#125; else &#123; if (strict) &#123; //开启严格模式，没找到对应key值，抛出错误 throw new Error('please transfer a valid prop path to form item!'); &#125; break; &#125; &#125; return &#123; o: tempObj, //原始数据 k: keyArr[i], //key值 v: tempObj ? tempObj[keyArr[i]] : null // key值对应的值 &#125;;&#125;; 31、GetUrlParam： 获取Url参数，返回一个对象12345678910111213function GetUrlParam()&#123; let url = document.location.toString(); let arrObj = url.split(\"?\"); let params = Object.create(null) if (arrObj.length &gt; 1)&#123; arrObj = arrObj[1].split(\"&amp;\"); arrObj.forEach(item=&gt;&#123; item = item.split(\"=\"); params[item[0]] = item[1] &#125;) &#125; return params;&#125;// ?a=1&amp;b=2&amp;c=3 ==&gt; &#123;a: \"1\", b: \"2\", c: \"3\"&#125; 32、downloadFile： base64数据导出文件，文件下载123456789101112131415161718function downloadFile(filename, data)&#123; let DownloadLink = document.createElement('a'); if ( DownloadLink )&#123; document.body.appendChild(DownloadLink); DownloadLink.style = 'display: none'; DownloadLink.download = filename; DownloadLink.href = data; if ( document.createEvent )&#123; let DownloadEvt = document.createEvent('MouseEvents'); DownloadEvt.initEvent('click', true, false); DownloadLink.dispatchEvent(DownloadEvt); &#125; else if ( document.createEventObject ) DownloadLink.fireEvent('onclick'); else if (typeof DownloadLink.onclick == 'function' ) DownloadLink.onclick(); document.body.removeChild(DownloadLink); &#125;&#125; 33、toFullScreen： 全屏1234567891011function toFullScreen()&#123; let elem = document.body; elem.webkitRequestFullScreen ? elem.webkitRequestFullScreen() : elem.mozRequestFullScreen ? elem.mozRequestFullScreen() : elem.msRequestFullscreen ? elem.msRequestFullscreen() : elem.requestFullScreen ? elem.requestFullScreen() : alert(\"浏览器不支持全屏\");&#125; 34、exitFullscreen：**退出全屏**12345678910111213function exitFullscreen()&#123; let elem = parent.document; elem.webkitCancelFullScreen ? elem.webkitCancelFullScreen() : elem.mozCancelFullScreen ? elem.mozCancelFullScreen() : elem.cancelFullScreen ? elem.cancelFullScreen() : elem.msExitFullscreen ? elem.msExitFullscreen() : elem.exitFullscreen ? elem.exitFullscreen() : alert(\"切换失败,可尝试Esc退出\");&#125; 35、requestAnimationFrame： window动画123456789101112131415161718window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function (callback) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.setTimeout(callback, 1000 / 60); &#125;; window.cancelAnimationFrame = window.cancelAnimationFrame || Window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.oCancelAnimationFrame || function (id) &#123; //为了使setTimteout的尽可能的接近每秒60帧的效果 window.clearTimeout(id); &#125; 36、_isNaN： 检查数据是否是非数字值原生的isNaN会把参数转换成数字(valueof)，而null、true、false以及长度小于等于1的数组(元素为非NaN数据)会被转换成数字，这不是我想要的。Symbol类型的数据不具有valueof接口，所以isNaN会抛出错误，这里放在后面，可避免错误 123function _isNaN(v)&#123; return !(typeof v === 'string' || typeof v === 'number') || isNaN(v)&#125; 37、max： 求取数组中非NaN数据中的最大值1234function max(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.max.apply(null, arr) : undefined&#125;//max([1, 2, '11', null, 'fdf', []]) ==&gt; 11 38、min：**求取数组中非NaN数据中的最小值**1234function min(arr)&#123; arr = arr.filter(item =&gt; !_isNaN(item)) return arr.length ? Math.min.apply(null, arr) : undefined&#125;//min([1, 2, '11', null, 'fdf', []]) ==&gt; 1 ## 39、random： 返回一个lower - upper之间的随机数lower、upper无论正负与大小，但必须是非NaN的数据 12345function random(lower, upper)&#123; lower = +lower || 0 upper = +upper || 0 return Math.random() * (upper - lower) + lower;&#125;//random(0, 0.5) ==&gt; 0.3567039135734613//random(2, 1) ===&gt; 1.6718418553475423//random(-2, -1) ==&gt; -1.4474325452361945 ## 40、Object.keys： 返回一个由一个给定对象的自身可枚举属性组成的数组1234567891011Object.keys = Object.keys || function keys(object) &#123; if(object === null || object === undefined)&#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if(isArrayLike(object) || isPlainObject(object))&#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; ( result.push(key) ) &#125; &#125; return result&#125; 41、Object.values： 返回一个给定对象自身的所有可枚举属性值的数组1234567891011Object.values = Object.values || function values(object) &#123; if(object === null || object === undefined)&#123; throw new TypeError('Cannot convert undefined or null to object'); &#125; let result = [] if(isArrayLike(object) || isPlainObject(object))&#123; for (let key in object) &#123; object.hasOwnProperty(key) &amp;&amp; ( result.push(object[key]) ) &#125; &#125; return result&#125; 42、arr.fill： 使用 value 值来填充 array，从start位置开始, 到end位置结束（但不包含end位置），返回原数组1234567891011121314151617181920Array.prototype.fill = Array.prototype.fill || function fill(value, start, end) &#123; let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start))&#123; start = 0 &#125;else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; end = parseInt(end) if(isNaN(end) || end &gt; length)&#123; end = length &#125;else if (end &lt; 0) &#123; end += length; &#125; while (start &lt; end) &#123; ctx[start++] = value; &#125; return ctx;&#125;//Array(3).fill(2) ===&gt; [2, 2, 2] 43、arr.includes： 用来判断一个数组是否包含一个指定的值，如果是返回 true，否则false，可指定开始查询的位置1234567891011Array.prototype.includes = Array.prototype.includes || function includes(value, start)&#123; let ctx = this let length = ctx.length; start = parseInt(start) if(isNaN(start))&#123; start = 0 &#125;else if (start &lt; 0) &#123; start = -start &gt; length ? 0 : (length + start); &#125; let index = ctx.indexOf(value) return index &gt;= start;&#125; 44、arr.find： 返回数组中通过测试（函数fn内判断）的第一个元素的值1234567Array.prototype.find = Array.prototype.find || function find(fn, ctx)&#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = value, true) : false &#125;) return result&#125; 45、arr.findIndex ： 返回数组中通过测试（函数fn内判断）的第一个元素的下标1234567Array.prototype.findIndex = Array.prototype.findIndex || function findIndex(fn, ctx)&#123; ctx = ctx || this let result; ctx.some((value, index, arr), thisValue) =&gt; &#123; return fn(value, index, arr) ? (result = index, true) : false &#125;) return result&#125; 46、performance.timing： 利用performance.timing进行性能分析1234567891011121314window.onload = function()&#123; setTimeout(function()&#123; let t = performance.timing console.log('DNS查询耗时 ：' + (t.domainLookupEnd - t.domainLookupStart).toFixed(0)) console.log('TCP链接耗时 ：' + (t.connectEnd - t.connectStart).toFixed(0)) console.log('request请求耗时 ：' + (t.responseEnd - t.responseStart).toFixed(0)) console.log('解析dom树耗时 ：' + (t.domComplete - t.domInteractive).toFixed(0)) console.log('白屏时间 ：' + (t.responseStart - t.navigationStart).toFixed(0)) console.log('domready时间 ：' + (t.domContentLoadedEventEnd - t.navigationStart).toFixed(0)) console.log('onload时间 ：' + (t.loadEventEnd - t.navigationStart).toFixed(0)) if(t = performance.memory)&#123; console.log('js内存使用占比 ：' + (t.usedJSHeapSize / t.totalJSHeapSize * 100).toFixed(2) + '%') &#125; &#125;)&#125; 47、禁止某些键盘事件1234567891011121314151617document.addEventListener('keydown', function(event)&#123; return !( 112 == event.keyCode || //F1 123 == event.keyCode || //F12 event.ctrlKey &amp;&amp; 82 == event.keyCode || //ctrl + R event.ctrlKey &amp;&amp; 78 == event.keyCode || //ctrl + N event.shiftKey &amp;&amp; 121 == event.keyCode || //shift + F10 event.altKey &amp;&amp; 115 == event.keyCode || //alt + F4 \"A\" == event.srcElement.tagName &amp;&amp; event.shiftKey //shift + 点击a标签 ) || (event.returnValue = false)&#125;); 48、禁止右键、选择、复制1234['contextmenu', 'selectstart', 'copy'].forEach(function(ev)&#123; document.addEventListener(ev, function(event)&#123; return event.returnValue = false &#125;)&#125;);","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"前端性能优化","slug":"前端性能优化总结","date":"2019-08-14T12:59:44.000Z","updated":"2019-08-15T00:58:32.377Z","comments":true,"path":"passages/前端性能优化总结/","link":"","permalink":"http://yoursite.com/passages/前端性能优化总结/","excerpt":"","text":"从输入URL加载起看方向从输入 URL 到页面加载完成的过程： 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了 TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件 CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了 我们从输入 URL 到显示页面这个过程中，涉及到网络层面的，有三个主要过程： DNS 解析 TCP 连接 HTTP 请求/响应 对于 DNS 解析和 TCP 连接两个步骤，我们前端可以做的努力非常有限。相比之下，HTTP 连接这一层面的优化才是我们网络优化的核心。 HTTP 优化有两个大的方向： 减少请求次数 减少单次请求所花费的时间 浏览器缓存策略 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache MemoryCache MemoryCache，是指存在内存中的缓存。从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。浏览器秉承的是“节约原则”，我们发现，Base64 格式的图片，几乎永远可以被塞进 memory cache，这可以视作浏览器为节省渲染开销的“自保行为”；此外，体积不大的 JS、CSS 文件，也有较大地被写入内存的几率——相比之下，较大的 JS、CSS 文件就没有这个待遇了，内存资源是有限的，它们往往被直接甩进磁盘。 Service Worker Cache Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。这样独立的个性使得 Service Worker 的“个人行为”无法干扰页面的性能，这个“幕后工作者”可以帮我们实现离线缓存、消息推送和网络代理等功能。我们借助 Service worker 实现的离线缓存就称为 Service Worker Cache。 HTTP Cache 它又分为强缓存和协商缓存。优先级较高的是强缓存，在命中强缓存失败的情况下，才会走协商缓存。 对一条http get 报文的基本缓存处理过程包括7个步骤： 接收 解析 查询，缓存查看是否有本地副本可用，如果没有，就获取一份副本 新鲜度检测， 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新。 创建响应，缓存会用新的首部和已缓存的主体来构建一条响应报文。 发送，缓存通过网络将响应发回给客服端。 日志 强缓存 强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的。强缓存中，当请求再次发出时，浏览器会根据其中的 expires 和 cache-control 判断目标资源是否“命中”强缓存，若命中则直接从缓存中获取资源，不会再与服务端发生通信。 是否足够新鲜时期： 通过 Expires: XXXX XXX XXX GMT （绝对日期时间，http/1.0） 或者 Cache-Control:max-age=XXXX （相对日期时间，http/1.1）在文档标明过期日期。 Cache-Control 相对于 expires 更加准确，它的优先级也更高。当 Cache-Control 与 expires 同时出现时，我们以 Cache-Control 为准。 关键字理解 public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。private 为默认值。 no-store与no-cache，no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即走我们下文即将讲解的协商缓存的路线）。no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。 协商缓存 协商缓存依赖于服务端与浏览器之间的通信。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304。 协商缓存的实现：从 Last-Modified 到 Etag，详细自己百度，这里不再详细展开。 HTTP 缓存决策 当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache；否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。 Push Cachae Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。 Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。 Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。 不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。 CDN CDN 的核心点有两个，一个是缓存，一个是回源。 “缓存”就是说我们把资源 copy 一份到 CDN 服务器上这个过程，“回源”就是说 CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程。 CDN 往往被用来存放静态资源。所谓“静态资源”，就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。而“动态资源”，顾名思义是需要后端实时动态生成的资源，较为常见的就是 JSP、ASP 或者依赖服务端渲染得到的 HTML 页面。 那“非纯静态资源”呢？它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。 另外，CDN的域名必须和主业务服务器的域名不一样，要不，同一个域名下面的Cookie各处跑，浪费了性能流量的开销，CDN域名放在不同的域名下，可以完美地避免了不必要的 Cookie 的出现！ 图片优化二进制位数与色彩的关系 在计算机中，像素用二进制数来表示。不同的图片格式中像素与二进制位数之间的对应关系是不同的。一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。 一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。 计算图片大小 对于一张 100 100 像素的图片来说，图像上有 10000 个像素点，如果每个像素的值是 RGBA 存储的话，那么也就是说每个像素有 4 个通道，每个通道 1 个字节（8 位 = 1个字节），所以该图片大小大概为 39KB（10000 1 * 4 / 1024）。 但是在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片类型要点 JPEG/JPG 特点：有损压缩、体积小、加载快、不支持透明,JPG 最大的特点是有损压缩。这种高效的压缩算法使它成为了一种非常轻巧的图片格式。另一方面，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。但当它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。 PNG 特点：无损压缩、质量高、体积大、支持透明，PNG（可移植网络图形格式）是一种无损压缩的高保真的图片格式。8 和 24，这里都是二进制数的位数。按照我们前置知识里提到的对应关系，8 位的 PNG 最多支持 256 种颜色，而 24 位的可以呈现约 1600 万种颜色。PNG 图片具有比 JPG 更强的色彩表现力，对线条的处理更加细腻，对透明度有良好的支持。它弥补了上文我们提到的 JPG 的局限性，唯一的 BUG 就是体积太大。 SVG 特点：文本文件、体积小、不失真、兼容性好，SVG（可缩放矢量图形）是一种基于 XML 语法的图像格式。它和本文提及的其它图片种类有着本质的不同：SVG 对图像的处理不是基于像素点，而是是基于对图像的形状描述。 Base64 特点：文本文件、依赖编码、小图标解决方案，Base64 并非一种图片格式，而是一种编码方式。Base64 和雪碧图一样，是作为小图标解决方案而存在的。 WebP 特点：年轻的全能型选手，WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。但是毕竟年轻，兼容性存在一些问题。 渲染优化客户端渲染 在客户端渲染模式下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，自己在浏览器里跑一遍 JS，根据 JS 的运行结果，生成相应的 DOM。页面上呈现的内容，你在 html 源文件里里找不到——这正是它的特点。 服务端渲染 在服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。页面上呈现的内容，我们在 html 源文件里也能找到。服务端渲染解决了一个非常关键的性能问题——首屏加载速度过慢，也解决了SEO搜索引擎的问题。 浏览器渲染过程解析 浏览器的渲染机制一般分为以下几个步骤： 处理 HTML 并构建 DOM 树。 处理 CSS 构建 CSSOM 树 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，计算每个节点的位置。 调用 GPU 绘制，合成图层，显示在屏幕上。 在渲染DOM的时候，浏览器所做的工作实际上是： 获取DOM后分割为多个图层 对每个图层的节点计算样式结果（Recalculate style–样式重计算） 为每个节点生成图形和位置（Layout–回流和重布局） 将每个节点绘制填充到图层位图中（Paint Setup和Paint–重绘） 图层作为纹理上传至GPU 复合多个图层到页面上生成最终屏幕图像（Composite Layers–图层重组） 基于渲染流程的CSS优化建议 CSS 选择符是从右到左进行匹配的，比如 #myList li {}实际开销相当高。 避免使用通配符，只对需要用到的元素进行选择。 关注可以通过继承实现的属性，避免重复匹配重复定义。 少用标签选择器。如果可以，用类选择器替代。错误：#dataList li{} 正确：.dataList{} 不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。错误：.dataList#title 正确：#title 减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。 CSS的阻塞 CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。即便 DOM 已经解析完毕了，只要 CSSOM 不 OK，那么渲染这个事情就不 OK。我们将 CSS 放在 head 标签里 和尽快 启用 CDN 实现静态资源加载速度的优化。 JS的阻塞 JS 引擎是独立于渲染引擎存在的。我们的 JS 代码在文档的何处插入，就在何处执行。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 DOM渲染优化先了解回流和重绘 回流：当我们对 DOM 的修改引发了 DOM 几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此受到影响），然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式（跳过了上图所示的回流环节）。这个过程叫做重绘。 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。在开发中，要从代码层面出发，尽可能把回流和重绘的次数最小化。 例子剖析 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;DOM操作测试&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 1234for(var count=0;count&lt;10000;count++)&#123; document.getElementById('container').innerHTML+='&lt;span&gt;我是一个小测试&lt;/span&gt;' //我们每一次循环都调用 DOM 接口重新获取了一次 container 元素，额外开销&#125; 进化一： 12345// 只获取一次containerlet container = document.getElementById('container')for(let count=0;count&lt;10000;count++)&#123; container.innerHTML += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; 进化二： 1234567//减少不必要的DOM更改let container = document.getElementById('container')let content = ''for(let count=0;count&lt;10000;count++)&#123; // 先对内容进行操作 content += '&lt;span&gt;我是一个小测试&lt;/span&gt;'&#125; // 内容处理好了,最后再触发DOM的更改container.innerHTML = content 事实上，考虑JS 的运行速度，比 DOM 快得多这个特性。我们减少 DOM 操作的核心思路，就是让 JS 去给 DOM 分压。 在 DOM Fragment 中，DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。 进化三： 1234567891011let container = document.getElementById('container')// 创建一个DOM Fragment对象作为容器let content = document.createDocumentFragment()for(let count=0;count&lt;10000;count++)&#123; // span此时可以通过DOM API去创建 let oSpan = document.createElement(\"span\") oSpan.innerHTML = '我是一个小测试' // 像操作真实DOM一样操作DOM Fragment对象 content.appendChild(oSpan)&#125;// 内容处理好了,最后再触发真实DOM的更改container.appendChild(content) 进化四： 当涉及到过万调数据进行渲染，而且要求不卡住画面，如何解决？如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; 控件 &lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000 // 一次插入 20 条，如果觉得性能不好就减少 const once = 20 // 渲染数据总共需要几次 const loopCount = total / once let countOfRender = 0 let ul = document.querySelector('ul') function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment() for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement('li') li.innerText = Math.floor(Math.random() * total) fragment.appendChild(li) &#125; ul.appendChild(fragment) countOfRender += 1 loop() &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add) &#125; &#125; loop() &#125;, 0) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 注意：若您想要在下次重绘时产生另一个动画画面，您的回调例程必须调用 requestAnimationFrame()。 Event Loop 我们先了解javascript运行机制，对渲染是大有帮助的。 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。 常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等。常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等。 例子分析： 12// task是一个用于修改DOM的回调setTimeout(task, 0) 上面代码，现在 task 被推入的 macro 队列。但因为 script 脚本本身是一个 macro 任务，所以本次执行完 script 脚本之后，下一个步骤就要去处理 micro 队列了，再往下就去执行了一次 render,必须等待下一次的loop。 1Promise.resolve().then(task) 上面代码，我们结束了对 script 脚本的执行，是不是紧接着就去处理 micro-task 队列了？micro-task 处理完，DOM 修改好了，紧接着就可以走 render 流程了——不需要再消耗多余的一次渲染，不需要再等待一轮事件循环，直接为用户呈现最即时的更新结果。 上面说了重绘与回流，Event loop，但很多人不知道的是，重绘和回流其实和 Event loop 有关。 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。 然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和 scroll 事件也是至少 16ms 才会触发一次，并且自带节流功能。 判断是否触发了 media query 更新动画并且发送事件 判断是否有全屏操作事件 执行 requestAnimationFrame 回调 执行 IntersectionObserver 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好 更新界面 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 requestIdleCallback 回调。 节流与防抖 当用户进行滚动，触发scroll事件，用户的每一次滚动都将触发我们的监听函数。函数执行是吃性能的，频繁地响应某个事件将造成大量不必要的页面计算。因此，我们需要针对那些有可能被频繁触发的事件作进一步地优化。节流与防抖就很有必要了！","categories":[],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"React-hanger","slug":"React-hanger","date":"2019-08-13T04:25:29.000Z","updated":"2019-08-13T04:26:57.898Z","comments":true,"path":"passages/React-hanger/","link":"","permalink":"http://yoursite.com/passages/React-hanger/","excerpt":"","text":"一 Hooks在Hooks之前，开发react组件主要是class组件和function组件。function组件没有state，所以也叫SFC（stateless functional component），简单的将props映射成view；class组件有state，能够处理更加复杂的逻辑。但是基于class的组建并不是完美的，总结起来就像Dan说的那样，有三个主要的问题： 代码重用：在hooks出来之前，常见的代码重用方式是HOCs和render props，这两种方式带来的问题是：你需要解构自己的组件，非常的笨重，同时会带来很深的组件嵌套 复杂的组件逻辑：在class组件中，有许多的lifecycle 函数，你需要在各个函数的里面去做对应的事情。这种方式带来的痛点是：逻辑分散在各处，开发者去维护这些代码会分散自己的精力，理解代码逻辑也很吃力 class组件的困惑：对于初学者来说，需要理解class组件里面的this是比较吃力的(这个理由有点勉强~)，同时，基于class的组件难以优化(举个不恰当的例子，看一下babel转移出来的class代码量增长了多少) 为了解决上面的这三个问题，react hooks提案登场了，它有以下几个特点： 无痛接入，不破坏现有的项目结构 完全向后兼容，不包含任何不兼容breaking changes 现在就能使用 Hooks 允许你在不编写 class 的情况下使用状态(state)和其他 React 特性。 你还可以构建自己的 Hooks, 跨组件共享可重用的有状态逻辑。 现在React中内置的Hooks有： Basic Hooks useState useEffect useContext Additional Hooks useReducer useCallback useMemo useRef useImperativeHandle useLayoutEffect useDebugValue 二 React-hangerreact-hanger的Usage里提供了6个API，从名字里就可以看出这些Hook都是做什么的(Hooks都以”use”开头，这是一种约定)， 123456789import &#123; useInput, useBoolean, useNumber, useArray, useOnMount, useOnUnmount&#125; from &quot;react-hanger&quot;; 使用起来也很简单，比如 useNumber 12345678910const App = () =&gt; &#123; const showCounter = useBoolean(true); const counter = useNumber(0); return ( &lt;div&gt; &lt;button onClick=&#123;counter.increase&#125;&gt; increase &lt;/button&gt; &#123;showCounter.value &amp;&amp; &lt;span&gt; &#123;counter.value&#125; &lt;/span&gt;&#125; &lt;button onClick=&#123;counter.decrease&#125;&gt; decrease &lt;/button&gt; &lt;/div&gt; )&#125;; 初步印象：大致与原始的basic hooks有点不同的是，useState返回一个数组，分别是 值与 操作，而react-hanger提供的API貌似是将 值和 一些操作封装到一个对象中，比如 counter就是一个 {value:count,increase:setCount(count+1),decrease:setCount(count-1)}的对象。 三 源码部分其实翻看了react-hanger的源码之后会发现，react-hanger一共引用了四个React内置的Hook， 1import &#123; useCallback, useEffect, useRef, useState &#125; from &quot;react&quot;; 然后返回一些“轮子”hooks，包括 useNumber、 useArray、 useBoolean等等。 这些轮子可以大致分为两类：封装Hook和拆分Hook。 封装Hook比如 useStateful、 useNumber、 useArray、 useBoolean都是对内置Hook useState的封装。 useStateful1234567export const useStateful = initial =&gt; &#123; const [value, setValue] = useState(initial); return &#123; value, setValue &#125;;&#125;; 利用ES6的解构赋值，将 useState返回的数组封装成一个对象重新返回，方便调用。 useNumber123456789101112131415export const useNumber = ( initial, &#123; upperLimit, lowerLimit, loop, step = 1 &#125; = &#123;&#125;) =&gt; &#123; const [value, setValue] = useState(initial); return &#123; value, setValue, increase: useCallback(i =&gt; &#123; setValue(...); &#125;,[]), decrease: useCallback(d =&gt; &#123; setValue(...); &#125;, []) &#125;;&#125;; useNumber接收一个initial number和一个配置项对象，在内部是通过对initial number进行useState Hook，返回一个对象，除了基本的 value和 setValue，还有两个方法 increase和 decrease。这两个方法都是用 useCallback对 setValue进行的进一步封装。 而 useCallback是一个比较重要的内置Hook， useCallback 的可以于缓存了每次渲染时 inline callback 的实例，在第二个参数数组内的值发生更改时才会更改。 这样可以配合上子组件的 shouldComponentUpdate 或者 useMemo 起到减少不必要的渲染的作用。 而第二个参数为空数组的意思就是告诉React不管参数如何都要记忆。 useArray &amp; useBoolean &amp; useInput至于 useArray 、 useBoolean 、 useInput这三个hook可以说和 useNumber大同小异，都是需要一个传入的initial值，在hook内部通过 useState初始化，再返回一些常用的操作方法。 这里的 useInput是针对于受控组件，所以不需要 useRef。 useSetState1234567891011export const useSetState = initialValue =&gt; &#123; const &#123; value, setValue &#125; = useStateful(initialValue); return &#123; setState: useCallback(v =&gt; &#123; return setValue(oldValue =&gt; (&#123; ...oldValue, ...(typeof v === &quot;function&quot; ? v(oldValue) : v) &#125;)); &#125;, []), state: value &#125;;&#125;; Unlike the setState method found in class components, useState does not automatically merge update objects. 与类组件中的setState方法不同，useState不会自动合并更新对象。 熟悉React Hook的同学看了代码就知道这个hook是封装了什么了，因为useState返回的类似于 setCount的方法不会自动合并更新对象。这个hook帮助大家可以获得一个可以merge之前value的Hook型 setState。 拆分Hook上述几个算是封装hook，那么下面的几个就可以算是拆分hook，对 useEffect更精细化的处理。 useOnMount &amp; useOnUnmount众所周知， useEffect是被用来处理一些原先放在class组件中生命周期函数的副作用，比如 componentDidMount、 componentDidUpdate、 componentWillUnmount，集合而成的一个Hook。 理论上，在每次渲染后都会触发 useEffect的效果，但是如果我只想在didmount里或者只想在willunmount里做一下事情，该怎么办？ 这时就用到了 useEffect的一个特点：第二个参数为效果依赖的值数组，也就是说只有当数组内的值变化才会触发 useEffect， 1234567useEffect( () =&gt; &#123; const subscription = props.source.subscribe(); return () =&gt; &#123; subscription.unsubscribe(); &#125;; &#125;, [props.source],); 而如果第二个参数为一个空数组的时候，则相当于告诉React你的效果不依赖于组件中的任何值，因此该效果只能在mount上运行并在unmount上清理，它不会在更新时运行。 123456export const useOnUnmount = onUnmount =&gt; useEffect(() =&gt; &#123; return () =&gt; onUnmount &amp;&amp; onUnmount();&#125;, []);export const useOnMount = onMount =&gt; useEffect(() =&gt; &#123; onMount &amp;&amp; onMount();&#125;, []); 所以 useOnMount的实现就非常简单，在 useEffect内执行onMount函数且第二个参数是 []， useOnUnmount的实现则是返回onUnmount函数且第二个参数是 []。 useLifecycleHooks1234export const useLifecycleHooks = (&#123; onMount, onUnmount &#125;) =&gt; useEffect(() =&gt; &#123; onMount &amp;&amp; onMount(); return () =&gt; onUnmount &amp;&amp; onUnmount();&#125;, []); useLifecycleHooks则是对 useOnUnmount和 useOnMount的整合，在 useEffect的第二个参数为 []的情况下，执行onMount和返回onUnmount。 useLogger12345678export const useLogger = (name, props) =&gt; &#123; useLifecycleHooks(&#123; onMount: () =&gt; console.log(`$&#123;name&#125; has mounted`), onUnmount: () =&gt; console.log(`$&#123;name&#125; has unmounted`) &#125;); useEffect(() =&gt; &#123; console.log(&quot;Props updated&quot;, props); &#125;);&#125;; useLogger算是一个为hook commponent封装的log插件，通过在 useLifecycleHooks内传入onMount和onUnmount打印日志的函数，之后再通过原生的默认 useEffect不传递第二个参数来实现在更新过程中打印日志。 usePrevious1234567export const usePrevious = value =&gt; &#123; const ref = useRef(); useEffect(() =&gt; &#123; ref.current = value; &#125;); return ref.current;&#125;; usePrevious则可以获取之前的props或者state，来自于React的官方文档。","categories":[],"tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"用JavaScript实现常用的数据结构","slug":"用JavaScript实现常用的数据结构","date":"2019-08-12T05:06:53.000Z","updated":"2019-08-12T05:08:13.193Z","comments":true,"path":"passages/用JavaScript实现常用的数据结构/","link":"","permalink":"http://yoursite.com/passages/用JavaScript实现常用的数据结构/","excerpt":"","text":"1.StackStack的特点是后进先出（last in first out）。生活中常见的Stack的例子比如一摞书，你最后放上去的那本你之后会最先拿走；又比如浏览器的访问历史，当点击返回按钮，最后访问的网站最先从历史记录中弹出 Stack一般具备以下方法： push：将一个元素推入栈顶 pop：移除栈顶元素，并返回被移除的元素 peek：返回栈顶元素 length：返回栈中元素的个数 Javascript的Array天生具备了Stack的特性，但我们也可以从头实现一个 Stack类： 123456789101112131415161718192021222324252627function Stack() &#123; this.count = 0; this.storage = &#123;&#125;; this.push = function (value) &#123; this.storage[this.count] = value; this.count++; &#125; this.pop = function () &#123; if (this.count === 0) &#123; return undefined; &#125; this.count--; var result = this.storage[this.count]; delete this.storage[this.count]; return result; &#125; this.peek = function () &#123; return this.storage[this.count - 1]; &#125; this.size = function () &#123; return this.count; &#125;&#125; 2.QueueQueue和Stack有一些类似，不同的是Stack是先进后出，而Queue是先进先出。Queue在生活中的例子比如排队上公交，排在第一个的总是最先上车；又比如打印机的打印队列，排在前面的最先打印。 Queue一般具有以下常见方法： enqueue：入列，向队列尾部增加一个元素 dequeue：出列，移除队列头部的一个元素并返回被移除的元素 front：获取队列的第一个元素 isEmpty：判断队列是否为空 size：获取队列中元素的个数 Javascript中的Array已经具备了Queue的一些特性，所以我们可以借助Array实现一个Queue类型： 123456789101112131415161718192021222324252627function Queue() &#123; var collection = []; this.print = function () &#123; console.log(collection); &#125; this.enqueue = function (element) &#123; collection.push(element); &#125; this.dequeue = function () &#123; return collection.shift(); &#125; this.front = function () &#123; return collection[0]; &#125; this.isEmpty = function () &#123; return collection.length === 0; &#125; this.size = function () &#123; return collection.length; &#125;&#125; Priority Queue Queue还有个升级版本，给每个元素赋予优先级，优先级高的元素入列时将排到低优先级元素之前。区别主要是enqueue方法的实现： 12345678910111213141516171819202122function PriorityQueue() &#123; ... this.enqueue = function (element) &#123; if (this.isEmpty()) &#123; collection.push(element); &#125; else &#123; var added = false; for (var i = 0; i &lt; collection.length; i++) &#123; if (element[1] &lt; collection[i][1]) &#123; collection.splice(i, 0, element); added = true; break; &#125; &#125; if (!added) &#123; collection.push(element); &#125; &#125; &#125;&#125; 通过以下代码测试可行性 12345678910111213141516var pQ = new PriorityQueue();pQ.enqueue(['gannicus', 3]);pQ.enqueue(['spartacus', 1]);pQ.enqueue(['crixus', 2]);pQ.enqueue(['oenomaus', 4]);pQ.print();//结果//[// [ 'spartacus', 1 ],// [ 'crixus', 2 ],// [ 'gannicus', 3 ],// [ 'oenomaus', 4 ]//] 3.Linked List链表是一种链式数据结构，链上的每个节点包含两种信息：节点本身的数据和指向下一个节点的指针。链表和传统的数组都是线性的数据结构，存储的都是一个序列的数据，但也有很多区别，如下表： 比较维度 数组 链表 内存分配 静态内存分配，编译时分配且连续 动态内存分配，运行时分配且不连续 元素获取 通过index获取，速度较快 通过遍历顺序访问，速递较慢 添加删除 速度较慢 速度更快 空间结构 可以是一维或者多维 可以是单向，双向或者循环链表 一个单向链表通常具有以下方法： size：返回链表中节点的个数 head：返回链表中的头部元素 add：向链表尾部增加一个节点 remove：删除某个节点 indexOf：返回某个节点的index elementAt：返回某个index处的节点 addAt：在某个index处插入一个节点 removeAt：删除某个index处的节点 单向链表的Javascript实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 链表中的节点 */function Node(element) &#123; // 节点中的数据 this.element = element; // 指向下一个节点的指针 this.next = null;&#125;function LinkedList() &#123; var length = 0; var head = null; this.size = function () &#123; return length; &#125; this.head = function () &#123; return head; &#125; this.add = function (element) &#123; var node = new Node(element); if (head == null) &#123; head = node; &#125; else &#123; var currentNode = head; while (currentNode.next) &#123; currentNode = currentNode.next; &#125; currentNode.next = node; &#125; length++; &#125; this.remove = function (element) &#123; var currentNode = head; var previousNode; if (currentNode.element === element) &#123; head = currentNode.next; &#125; else &#123; while (currentNode.element !== element) &#123; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; &#125; length--; &#125; this.isEmpty = function () &#123; return length === 0; &#125; this.indexOf = function (element) &#123; var currentNode = head; var index = -1; while (currentNode) &#123; index++; if (currentNode.element === element) &#123; return index; &#125; currentNode = currentNode.next; &#125; return -1; &#125; this.elementAt = function (index) &#123; var currentNode = head; var count = 0; while (count &lt; index) &#123; count++; currentNode = currentNode.next; &#125; return currentNode.element; &#125; this.addAt = function (index, element) &#123; var node = new Node(element); var currentNode = head; var previousNode; var currentIndex = 0; if (index &gt; length) &#123; return false; &#125; if (index === 0) &#123; node.next = currentNode; head = node; &#125; else &#123; while (currentIndex &lt; index) &#123; currentIndex++; previousNode = currentNode; currentNode = currentNode.next; &#125; node.next = currentNode; previousNode.next = node; &#125; length++; &#125; this.removeAt = function (index) &#123; var currentNode = head; var previousNode; var currentIndex = 0; if (index &lt; 0 || index &gt;= length) &#123; return null; &#125; if (index === 0) &#123; head = currentIndex.next; &#125; else &#123; while (currentIndex &lt; index) &#123; currentIndex++; previousNode = currentNode; currentNode = currentNode.next; &#125; previousNode.next = currentNode.next; &#125; length--; return currentNode.element; &#125;&#125; 4.Set集合表示具有某种特性的对象汇总成的集体。在ES6中也引入了集合类型Set，Set和Array有一定程度的相似，不同的是Set中不允许出现重复的元素而且是无序的。 一个典型的Set应该具有以下方法： values：返回集合中的所有元素 size：返回集合中元素的个数 has：判断集合中是否存在某个元素 add：向集合中添加元素 remove：从集合中移除某个元素 union：返回两个集合的并集 intersection：返回两个集合的交集 difference：返回两个集合的差集 subset：判断一个集合是否为另一个集合的子集 使用Javascript可以将Set进行如下实现，为了区别于ES6中的Set命名为MySet： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function MySet() &#123; var collection = []; this.has = function (element) &#123; return (collection.indexOf(element) !== -1); &#125; this.values = function () &#123; return collection; &#125; this.size = function () &#123; return collection.length; &#125; this.add = function (element) &#123; if (!this.has(element)) &#123; collection.push(element); return true; &#125; return false; &#125; this.remove = function (element) &#123; if (this.has(element)) &#123; index = collection.indexOf(element); collection.splice(index, 1); return true; &#125; return false; &#125; this.union = function (otherSet) &#123; var unionSet = new MySet(); var firstSet = this.values(); var secondSet = otherSet.values(); firstSet.forEach(function (e) &#123; unionSet.add(e); &#125;); secondSet.forEach(function (e) &#123; unionSet.add(e); &#125;); return unionSet; &#125; this.intersection = function (otherSet) &#123; var intersectionSet = new MySet(); var firstSet = this.values(); firstSet.forEach(function (e) &#123; if (otherSet.has(e)) &#123; intersectionSet.add(e); &#125; &#125;); return intersectionSet; &#125; this.difference = function (otherSet) &#123; var differenceSet = new MySet(); var firstSet = this.values(); firstSet.forEach(function (e) &#123; if (!otherSet.has(e)) &#123; differenceSet.add(e); &#125; &#125;); return differenceSet; &#125; this.subset = function (otherSet) &#123; var firstSet = this.values(); return firstSet.every(function (value) &#123; return otherSet.has(value); &#125;); &#125;&#125; 5.Hash TableHash Table是一种用于存储键值对（key value pair）的数据结构，因为Hash Table根据key查询value的速度很快，所以它常用于实现Map、Dictinary、Object等数据结构。如上图所示，Hash Table内部使用一个hash函数将传入的键转换成一串数字，而这串数字将作为键值对实际的key，通过这个key查询对应的value非常快，时间复杂度将达到O(1)。Hash函数要求相同输入对应的输出必须相等，而不同输入对应的输出必须不等，相当于对每对数据打上唯一的指纹。 一个Hash Table通常具有下列方法： add：增加一组键值对 remove：删除一组键值对 lookup：查找一个键对应的值 一个简易版本的Hash Table的Javascript实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758function hash(string, max) &#123; var hash = 0; for (var i = 0; i &lt; string.length; i++) &#123; hash += string.charCodeAt(i); &#125; return hash % max;&#125;function HashTable() &#123; let storage = []; const storageLimit = 4; this.add = function (key, value) &#123; var index = hash(key, storageLimit); if (storage[index] === undefined) &#123; storage[index] = [ [key, value] ]; &#125; else &#123; var inserted = false; for (var i = 0; i &lt; storage[index].length; i++) &#123; if (storage[index][i][0] === key) &#123; storage[index][i][1] = value; inserted = true; &#125; &#125; if (inserted === false) &#123; storage[index].push([key, value]); &#125; &#125; &#125; this.remove = function (key) &#123; var index = hash(key, storageLimit); if (storage[index].length === 1 &amp;&amp; storage[index][0][0] === key) &#123; delete storage[index]; &#125; else &#123; for (var i = 0; i &lt; storage[index]; i++) &#123; if (storage[index][i][0] === key) &#123; delete storage[index][i]; &#125; &#125; &#125; &#125; this.lookup = function (key) &#123; var index = hash(key, storageLimit); if (storage[index] === undefined) &#123; return undefined; &#125; else &#123; for (var i = 0; i &lt; storage[index].length; i++) &#123; if (storage[index][i][0] === key) &#123; return storage[index][i][1]; &#125; &#125; &#125; &#125;&#125; 6.TreeTree的数据结构和自然界中的树极其相似，有根、树枝、叶子，如上图所示。Tree是一种多层数据结构，与Array、Stack、Queue相比是一种非线性的数据结构，在进行插入和搜索操作时很高效。在描述一个Tree时经常会用到下列概念： Root（根）：代表树的根节点，根节点没有父节点 Parent Node（父节点）：一个节点的直接上级节点，只有一个 Child Node（子节点）：一个节点的直接下级节点，可能有多个 Siblings（兄弟节点）：具有相同父节点的节点 Leaf（叶节点）：没有子节点的节点 Edge（边）：两个节点之间的连接线 Path（路径）：从源节点到目标节点的连续边 Height of Node（节点的高度）：表示节点与叶节点之间的最长路径上边的个数 Height of Tree（树的高度）：即根节点的高度 Depth of Node（节点的深度）：表示从根节点到该节点的边的个数 Degree of Node（节点的度）：表示子节点的个数 我们以二叉查找树为例，展示树在Javascript中的实现。在二叉查找树中，即每个节点最多只有两个子节点，而左侧子节点小于当前节点，而右侧子节点大于当前节点 一个二叉查找树应该具有以下常用方法： add：向树中插入一个节点 findMin：查找树中最小的节点 findMax：查找树中最大的节点 find：查找树中的某个节点 isPresent：判断某个节点在树中是否存在 remove：移除树中的某个节点 以下是二叉查找树的Javascript实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125class Node &#123; constructor(data, left = null, right = null) &#123; this.data = data; this.left = left; this.right = right; &#125;&#125;class BST &#123; constructor() &#123; this.root = null; &#125; add(data) &#123; const node = this.root; if (node === null) &#123; this.root = new Node(data); return; &#125; else &#123; const searchTree = function (node) &#123; if (data &lt; node.data) &#123; if (node.left === null) &#123; node.left = new Node(data); return; &#125; else if (node.left !== null) &#123; return searchTree(node.left); &#125; &#125; else if (data &gt; node.data) &#123; if (node.right === null) &#123; node.right = new Node(data); return; &#125; else if (node.right !== null) &#123; return searchTree(node.right); &#125; &#125; else &#123; return null; &#125; &#125;; return searchTree(node); &#125; &#125; findMin() &#123; let current = this.root; while (current.left !== null) &#123; current = current.left; &#125; return current.data; &#125; findMax() &#123; let current = this.root; while (current.right !== null) &#123; current = current.right; &#125; return current.data; &#125; find(data) &#123; let current = this.root; while (current.data !== data) &#123; if (data &lt; current.data) &#123; current = current.left &#125; else &#123; current = current.right; &#125; if (current === null) &#123; return null; &#125; &#125; return current; &#125; isPresent(data) &#123; let current = this.root; while (current) &#123; if (data === current.data) &#123; return true; &#125; if (data &lt; current.data) &#123; current = current.left; &#125; else &#123; current = current.right; &#125; &#125; return false; &#125; remove(data) &#123; const removeNode = function (node, data) &#123; if (node == null) &#123; return null; &#125; if (data == node.data) &#123; // node没有子节点 if (node.left == null &amp;&amp; node.right == null) &#123; return null; &#125; // node没有左侧子节点 if (node.left == null) &#123; return node.right; &#125; // node没有右侧子节点 if (node.right == null) &#123; return node.left; &#125; // node有两个子节点 var tempNode = node.right; while (tempNode.left !== null) &#123; tempNode = tempNode.left; &#125; node.data = tempNode.data; node.right = removeNode(node.right, tempNode.data); return node; &#125; else if (data &lt; node.data) &#123; node.left = removeNode(node.left, data); return node; &#125; else &#123; node.right = removeNode(node.right, data); return node; &#125; &#125; this.root = removeNode(this.root, data); &#125;&#125; 例如： 123456789101112131415161718192021const bst = new BST();bst.add(4);bst.add(2);bst.add(6);bst.add(1);bst.add(3);bst.add(5);bst.add(7);bst.remove(4);console.log(bst.findMin());console.log(bst.findMax());bst.remove(7);console.log(bst.findMax());console.log(bst.isPresent(4));//结果//1//7//6//false 7.GraphGraph是节点（或顶点）以及它们之间的连接（或边）的集合。Graph也可以称为Network（网络）。根据节点之间的连接是否有方向又可以分为Directed Graph（有向图）和Undrected Graph（无向图）。Graph在实际生活中有很多用途，比如：导航软件计算最佳路径，社交软件进行好友推荐等等。 Graph通常有两种表达方式： Adjaceny List（邻接列表）： ​ 邻接列表可以表示为左侧是节点的列表，右侧列出它所连接的所有其他节点。 Adjacency Matrix（邻接矩阵）： 邻接矩阵用矩阵来表示节点之间的连接关系，每行或者每列表示一个节点，行和列的交叉处的数字表示节点之间的关系：0表示没用连接，1表示有连接，大于1表示不同的权重。 访问Graph中的节点需要使用遍历算法，遍历算法又分为广度优先和深度优先，主要用于确定目标节点和根节点之间的距离， 在Javascript中，Graph可以用一个矩阵（二维数组）表示，广度优先搜索算法可以实现如下： 123456789101112131415161718192021222324252627282930313233function bfs(graph, root) &#123; var nodesLen = &#123;&#125;; for (var i = 0; i &lt; graph.length; i++) &#123; nodesLen[i] = Infinity; &#125; nodesLen[root] = 0; var queue = [root]; var current; while (queue.length != 0) &#123; current = queue.shift(); var curConnected = graph[current]; var neighborIdx = []; var idx = curConnected.indexOf(1); while (idx != -1) &#123; neighborIdx.push(idx); idx = curConnected.indexOf(1, idx + 1); &#125; for (var j = 0; j &lt; neighborIdx.length; j++) &#123; if (nodesLen[neighborIdx[j]] == Infinity) &#123; nodesLen[neighborIdx[j]] = nodesLen[current] + 1; queue.push(neighborIdx[j]); &#125; &#125; &#125; return nodesLen;&#125;","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://yoursite.com/tags/数据结构/"}]},{"title":"同步与异步","slug":"同步与异步","date":"2019-08-11T06:01:16.000Z","updated":"2019-08-11T06:02:28.189Z","comments":true,"path":"passages/同步与异步/","link":"","permalink":"http://yoursite.com/passages/同步与异步/","excerpt":"","text":"一 关于JavaScriptJavaScript是一门单线程语言，在最新的HTML5中提出了Web-Worker，但JavaScript是单线程这一核心仍未改变。所以一切JavaScript版的”多线程”都是用单线程模拟出来的。 二 JavaScript的事件循环既然JS是单线程，就像只有一个窗口的银行，客户需要排队一个一个办理业务，同理JS任务也要一个一个顺序执行。如果一个任务耗时过长，那么后一个任务也必须等着。那么问题来了，假如我想浏览新闻，但是新闻包含的超清图片加载很慢，难道网页要一直卡着直到图片完全显示出来？因此，可以将任务分为两类来解决问题： 同步任务 异步任务 当打开网站时，网页的渲染过程就是一大堆同步任务，比如页面骨架和页面元素的渲染。而像加载图片音乐之类占用资源大耗时久的任务，就是异步任务。 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数。当指定的事情完成时，Event Table会将这个函数移入Event Queue。主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。上述过程会不断重复，也就是常说的Event Loop(事件循环)。 那如何判断主线程执行栈是否为空？ JS引擎中存在monitoring process进程，它会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 例如： 123456789let data = [];$.ajax(&#123; url:www.javascript.com, data:data, success:() =&gt; &#123; console.log('发送成功!'); &#125;&#125;)console.log('代码执行结束'); 上面是一段简易的ajax请求代码： ajax进入Event Table，注册回调函数success。 执行console.log(‘代码执行结束’)。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 三 setTimeout函数 setTimeout是异步的 举例： 12345setTimeout(() =&gt; &#123; task()&#125;,3000)sleep(10000000)// sleep代表一个执行需要耗时很久的函数，并不是真实的sleep函数 发现执行Task()的时间元超过3秒。为什么呢？ 首先上面的代码执行过程 task()进入Event Table并注册,计时开始。 执行sleep函数，很慢，非常慢，计时仍在继续。 3秒到了，计时事件timeout完成，task()进入Event Queue，但是sleep还没执行完，只好等着。 sleep终于执行完了，task()终于从Event Queue进入了主线程执行。 上述的流程走完，可以知道setTimeout这个函数，是经过指定时间后，把要执行的任务(本例中为task())加入到Event Queue中，又因为是单线程任务要一个一个执行，如果前面的任务需要的时间太久，那么只能等着，导致真正的延迟时间远远大于3秒。 补充： setTimeout(fn,0)的含义是，指定某个任务在主线程最早可得的空闲时间执行，意思就是不用再等多少秒了，只要主线程执行栈内的同步任务全部执行完成，栈为空就马上执行 四 Promise和process.nextTick（callback）首先我们可以继续将任务细分 - macro-task(宏任务)：包括整体代码script，setTimeout，setInterval- micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue 123456789101112131415161718setTimeout(function() &#123; console.log('setTimeout');&#125;)new Promise(function(resolve) &#123; console.log('promise'); resolve();// 在浏览器里，Promise没写resolve，'then'是不会输出的，这里为了方便演示人为添加执行&#125;).then(function() &#123; console.log('then');&#125;)console.log('console');//结果// promise// console// then// setTimeout 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 整体代码script作为第一个宏任务执行结束，看看有哪些微任务？我们发现了then在微任务Event Queue里面，执行。 第一轮事件循环结束了，我们开始第二轮循环，当然要从宏任务Event Queue开始。我们发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行。 结束。 接下来这段代码更具有典型性 123456789101112131415161718192021222324252627282930313233343536console.log('1');setTimeout(function() &#123; console.log('2'); process.nextTick(function() &#123; console.log('3'); &#125;) new Promise(function(resolve) &#123; console.log('4'); resolve(); &#125;).then(function() &#123; console.log('5') &#125;)&#125;)process.nextTick(function() &#123; console.log('6');&#125;)new Promise(function(resolve) &#123; console.log('7'); resolve();&#125;).then(function() &#123; console.log('8')&#125;)setTimeout(function() &#123; console.log('9'); process.nextTick(function() &#123; console.log('10'); &#125;) new Promise(function(resolve) &#123; console.log('11'); resolve(); &#125;).then(function() &#123; console.log('12') &#125;)&#125;) 第一轮事件循环流程分析如下： 整体script作为第一个宏任务进入主线程，遇到console.log，输出1。 遇到setTimeout，其回调函数被分发到宏任务Event Queue中。我们暂且记为setTimeout1。 遇到process.nextTick()，其回调函数被分发到微任务Event Queue中。我们记为process1。 遇到Promise，new Promise直接执行，输出7。then被分发到微任务Event Queue中。我们记为then1。 又遇到了setTimeout，其回调函数被分发到宏任务Event Queue中，我们记为setTimeout2。 上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。 我们发现了process1和then1两个微任务。 执行process1,输出6。 执行then1，输出8。 第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。那么第二轮时间循环从setTimeout1宏任务开始： 首先输出2。接下来遇到了process.nextTick()，同样将其分发到微任务Event Queue中，记为process2。new Promise立即执行输出4，then也分发到微任务Event Queue中，记为then2。 第二轮事件循环宏任务结束，我们发现有process2和then2两个微任务可以执行。 输出3。 输出5。 第二轮事件循环结束，第二轮输出2，4，3，5。 第三轮事件循环开始，此时只剩setTimeout2了，执行。 直接输出9。 将process.nextTick()分发到微任务Event Queue中。记为process3。 直接执行new Promise，输出11。 将then分发到微任务Event Queue中，记为then3。 第三轮事件循环宏任务执行结束，执行两个微任务process3和then3。 输出10。 输出12。 第三轮事件循环结束，第三轮输出9，11，10，12。 整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。（浏览器环境）","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}]},{"title":"让小程序支持jsx语法","slug":"让小程序支持jsx语法","date":"2019-08-10T05:11:32.000Z","updated":"2019-08-10T05:38:59.298Z","comments":true,"path":"passages/让小程序支持jsx语法/","link":"","permalink":"http://yoursite.com/passages/让小程序支持jsx语法/","excerpt":"","text":"一 现有思路的局限性先看看 Taro， nanachi是怎么在小程序端处理 JSX语法的。简单来说，主要是通过在编译阶段把 JSX转化为等效的小程序 wxml来把 React代码运行在小程序端的 比如将 1xx &amp;&amp; &lt;Text&gt;hello&lt;/Text&gt; 将会被转化为wx：if 1&lt;Text wx:if=&quot;&#123;&#123;xx&#125;&#125;&quot;&gt;Hello&lt;/Text&gt; 这种方式把对 JSX的处理，主要放在了编译阶段，他依赖于编译阶段的信息收集，以上面为例，它必须识别出逻辑表达式，然后做对应的 wx:if转换处理。 那编译阶段有什么问题和局限呢？ 1234567891011class App extends React.Component &#123; render()&#123; const a=&lt;Text&gt;hello&lt;/Text&gt; const b=a return ( &lt;View&gt; &#123;b&#125; &lt;/View&gt; ) &#125;&#125; 首先我们声明 consta=&lt;Text&gt;Hello&lt;/Text&gt;，然后把 a赋值给了 b，在最新版本 Taro1.3的转换后报错了！！！ a is not defined 为什么呢？ 想理解上面的代码为什么报错，我们首先要理解编译阶段。本质上来说在编译阶段，代码其实就是‘字符串’，而编译阶段处理方案，就需要从这个‘字符串’中分析出必要的信息（通过 AST，正则等方式）然后做对应的等效转换处理。 而对于上面的例子，需要做什么等效处理呢？需要我们在编译阶段分析出 b是 JSX片段：b=a=&lt;Text&gt;Hello&lt;/Text&gt;，然后把 &lt;View&gt;{b}&lt;/View&gt;中的 {b}等效替换为 &lt;Text&gt;Hello&lt;/Text&gt;。然而在编译阶段要想确定 b的值是很困难的，有人说可以往前追溯来确定b的值，也不是不可以，但是考虑一下 由于 b=a，那么就先要确定 a的值，这个 a的值怎么确定呢？需要在 b可以访问到的作用域链中确定 a，然而 a可能又是由其他变量赋值而来，循环往复，期间一旦出现不是简单赋值的情况，比如函数调用，三元判断等运行时信息，追溯就宣告失败，要是 a本身就是挂在全局对象上的变量，追溯就更加无从谈起。 所以在编译阶段 是无法简单确定 b的值的。 我们再仔细看下报错信息：a is not defined。 什么说 a未定义呢？这是涉及到另外一个问题，我们知道 &lt;Text&gt;Hello&lt;/Text&gt;，其实等效于 React.createElement(Text,null,&#39;Hello&#39;)，而 React.createElement方法的返回值就是一个普通 JS对象 123456&#123; tag:Text, props:null, children:'hello' ...&#125; 所以上面那一段代码在 JS环境真正运行的时候，大概等效如下： 1234567891011121314151617class App extends React.Component &#123; render()&#123; const a=&#123; tag:Text, props:null, children:&apos;hello&apos; ... &#125; const b=a return &#123; tag:View, props:null, children:b ... &#125; &#125;&#125; 但是，之前说编译阶段需要对 JSX做等效处理，需要把 JSX转换为 wxml，所以 &lt;Text&gt;Hello&lt;/Text&gt;这个 JSX片段被特殊处理了， a不再是一个普通 js对象，这里我们看到 a变量甚至丢失了，这里暴露了一个很严重的问题：代码语义被破坏了，也就是说由于编译时方案对 JSX的特殊处理，真正运行在小程序上的代码语义并不是你的预期。 二 新的思路下面我们介绍一种全新的处理思路，这种思路在小程序运行期间和真正的 React几无区别，不会改变任何代码语义， JSX表达式只会被处理为 React.createElement方法调用，实际运行的时候就是普通 js对象，最终通过其他方式渲染出小程序视图。 12345678910111213141516171819202122232425262728293031323334353637383940414243第一步：给每个独立的 `JSX`片段打上唯一标识 `uuid`，例如：const a=&lt;Text uuid=&apos;00001&apos;&gt;&lt;/Text&gt;const y=&lt;View uuid=&apos;00002&apos;&gt; &lt;Image&gt;&lt;/Image&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; 我们给 `a`片段， `y`片段 添加了 `uuid`属性第二步：把 `React`代码通过 `babel`转义为小程序可以识别的代码，例如 `JSX`片段用等效的 `React.createElement`替换等const a=React.createElement(Text,&#123; uuid:&apos;00001&apos;&#125;,&apos;hello&apos;)第三步：提取每个独立的 `JSX`片段，用小程序 `template`包裹，生成 `wxml`文件&lt;template name=&apos;00001&apos;&gt; &lt;Text&gt;hello&lt;/Text&gt;&lt;/template&gt;&lt;template name=&apos;00002&apos;&gt; &lt;View uuid=&apos;00002&apos;&gt; &lt;Image&gt;&lt;/Image&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt;&lt;/template&gt;&lt;template is=&quot;&#123;&#123;uiDes.name&#125;&#125;&quot; data=&quot;&#123;&#123;...uiDes&#125;&#125;&quot;&gt;&lt;/template&gt; 注意这里每一个 `template` 的 `name`标识和 `JSX`片段的唯一标识 `uuid`是一样的。最后，需要在结尾生成一个占位模版：`&lt;templateis=&quot;&#123;&#123;uiDes.name&#125;&#125;&quot;data=&quot;&#123;&#123;...uiDes&#125;&#125;&quot;/&gt;`。第四步：修改 `ReactDOM.render`的递归（ `React16.x`之后，不在是递归的方式）过程，递归执行阶段，聚合 `JSX`片段的 `uuid`属性，生成并返回 `uiDes`数据结构。第五步：把第四步生成的 `uiDes`，传递给小程序环境，小程序把 `uiDes` 设置给占位模版 `&lt;templateis=&quot;&#123;&#123;uiDes.name&#125;&#125;&quot;data=&quot;&#123;&#123;...uiDes&#125;&#125;&quot;/&gt;`，渲染出最终的视图。const uiDes=&#123; name:&apos;00002&apos;, child0001:&#123; name:00001, ... &#125; ...&#125; 在这整个过程中，你的所有 JS代码都是运行在 React过程中的，语义完全一致， JSX片段也不会被任何特殊处理，只是简单的 React.createElement调用，另外由于这里的 React过程只是纯 js运算，执行是非常迅速的，通常只有几ms。最终会输出一个 uiDes数据到小程序，小程序通过这个 uiDes渲染出视图。 现在我们在看之前的赋值 const b=a，就不会有任何问题了，因为 a 不过是普通对象。另外对于常见的编译时方案的限制，比如任意函数返回 JSX片段，动态生成 JSX片段， for循环使用 JSX片段等等，都可以完全解除了，因为 JSX片段只是 js对象，你可以做任何操作，最终 ReactDOM.render会搜集所有执行结果的片段的 uuid标识，生成 uiDes，而小程序会根据这个 uiDes数据结构渲染出最终视图。 可以看出这种新的思路和以前编译时方案还是有很大的区别的，对 JSX片段的处理是动态的，你可以在任何地方，任何函数出现任何 JSX片段, 最终执行结果会确定渲染哪一个片段，只有执行结果的片段的 uuid会被写入 uiDes。这和编译时方案的静态识别有着本质的区别。","categories":[],"tags":[{"name":"jsx","slug":"jsx","permalink":"http://yoursite.com/tags/jsx/"}]},{"title":"iframe的实际应用","slug":"iframe的实际应用","date":"2019-08-09T05:10:14.000Z","updated":"2019-08-09T05:12:23.205Z","comments":true,"path":"passages/iframe的实际应用/","link":"","permalink":"http://yoursite.com/passages/iframe的实际应用/","excerpt":"","text":"一 何为iframeiframe是一个标签dom元素, 我们可以使用向一个网页里嵌入另一个网页，以及用在导航栏tab切换页（古老的做法）、在线编辑器、广告植入，以及跨域通信等 二 iframe的优点和缺点优点解决跨域问题（已经很少使用了） 缺点触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。如果含有多个iframe,那么window 的 onload事件需要在所有 iframe 加载完毕后(包含里面的元素)才会触发。通过JavaScript 动态设置 iframe 的 Src 可以避免这种阻塞情况 三 iframe的使用 不管是获取子iframe还是父iframe都受跨域限制 获取子窗口 document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow document.getElementsById(&#39;id&#39;).contentWindow 简易写法 window.frames[&#39;iframe的name&#39;] IE专用 document.iframes[name].contentWindow document.iframes[i].contentWindow 父子页面窗口的关系 window.self: 就是自己 window.parent: 父级窗口对象 window.top: 顶级窗口对象 父子窗口通信等待子iframe加载完成后可以通过iframe.contentWindow.变量访问子窗口 判断iframe加载完成 非ie下使用onload事件 1iframe(dom元素).onload = function () &#123;&#125; ie下使用onreadystatechange或者设定计时器 12345iframe.onreadystatechange = function()&#123; if (iframe.readyState == &quot;complete&quot; || iframe.readyState == &apos;&apos;loaded”)&#123; alert(&quot;Local iframe is now loaded.&quot;); &#125; &#125; 父访问子和子访问父涉都会及跨域问题 iframe受跨域限制如何解决 document.domain: 解决跨域限制最好的办法,而且域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法跨域。 window.location.hash: 解决父页面向子页面传递数据问题(window.location.href)，不论是否跨域，都可以取得后面的hash值，即锚点后面的值，所以可使用锚点来传输数据，如下&lt;iframe src=&#39;http://baidu.com#1&#39;&gt;,然后在子页面中使用定时器定时访问location.hash来获得传过来的值，如下图所示，注意里面lasthash的使用 12345678var age=20var lastHash = window.location.hash;setInterval(function(0&#123; if(lastHash!=window.location.hash)&#123; console.log(location.hash.slice(1)) lastHash=window.location.hash&#125; &#125;),10) window.name: 解决父页面访问子页面的数据问题，window.name是放在整个窗口上，只要该浏览器窗口没有关闭，一个标签下，不管两个页面是否同源,以及是否刷星，window.name就可以取到，但是对于一个页面中镶嵌另外一个iframe，由于iframe是一个新的页面含有新的window，所以不能直接用window.name取得iframe中的window.name由于是不同的window,像下面这样使用window.name 1234567891011121314&lt;iframe src='https://still-caverns-23465.herokuapp.com/ds.html' frameborder='0' name='ds'&gt;&lt;/iframe&gt;&lt;script&gt; var oIframe=document.getElementByTagName('iframe')[0] var oldAge=55 var flag=true oIframe.onload=function()&#123; if(flag)&#123; oIframe.src='./xl.html' flag=false &#125;else &#123; console.log(oIframe.contentWindow.name) &#125; &#125;&lt;/script&gt; 实现的思路是当子iframe加载完成后，我们替换掉iframe的src为当前页面的同源页面，这样我们就可以借助这个同源页面去iframe里面取window.name了","categories":[],"tags":[{"name":"iframe","slug":"iframe","permalink":"http://yoursite.com/tags/iframe/"}]},{"title":"重绘，重排与性能优化","slug":"重绘，重排与性能优化","date":"2019-08-08T05:11:21.000Z","updated":"2019-08-08T05:14:28.795Z","comments":true,"path":"passages/重绘，重排与性能优化/","link":"","permalink":"http://yoursite.com/passages/重绘，重排与性能优化/","excerpt":"","text":"一.什么是重绘与重排浏览器下载完页面中的所有组件——HTML标记、JavaScript、CSS、图片之后会解析生成两个内部数据结构——DOM树和渲染树。 DOM树表示页面结构，渲染树表示DOM节点如何显示。DOM树中的每一个需要显示的节点在渲染树种至少存在一个对应的节点（隐藏的DOM元素disply值为none 在渲染树中没有对应的节点）。渲染树中的节点被称为“帧”或“盒”,符合CSS模型的定义，理解页面元素为一个具有填充，边距，边框和位置的盒子。一旦DOM和渲染树构建完成，浏览器就开始显示（绘制）页面元素。 当DOM的变化影响了元素的几何属性（宽或高），浏览器需要重新计算元素的几何属性，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这个过程称为重排。完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性，通常要花3倍于同等元素的时间。这也是为什么我们要避免使用table做布局的一个原因。 并不是所有的DOM变化都会影响几何属性，比如改变一个元素的背景色并不会影响元素的宽和高，这种情况下只会发生重绘。 不管页面发生了重绘还是重排，它们都会影响性能 二.怎样触发重排页面布局和元素几何属性的改变就会导致重排下列情况会发生重排 页面初始渲染 添加/删除可见DOM元素 改变元素位置 改变元素尺寸（宽、高、内外边距、边框等） 改变元素内容（文本或图片等） 改变窗口尺寸 不同的条件下发生重排的范围及程度会不同某些情况甚至会重排整个页面，比如滑动滚动条 三.浏览器优化例如： 假如我要用js修改某个div的样式 1234div.style.left = '10px';div.style.top = '10px';div.style.width = '10px';div.style.height = '10px'; 我们修改了元素的left、top、width、height属性 ,满足我们发生重排的条件 ,理论上会发生4次重排 ,但是实际上只会发生1次重排 ,因为我们现代的浏览器都有渲染队列的机制 ,当我改变了元素的一个样式会导致浏览器发生重排或重绘时 ,它会进入一个渲染队列 ,然后浏览器继续往下看，如果下面还有样式修改 ,那么同样入队 ,直到下面没有样式修改 ,浏览器会按照渲染队列批量执行来优化重排过程，一并修改样式 ,这样就把本该4次的重排优化为1次 But,当我们写如下代码时： 1234567891011div.style.left = '10px';console.log(div.offsetLeft);div.style.top = '10px';console.log(div.offsetTop);div.style.width = '20px';console.log(div.offsetWidth);div.style.height = '20px';console.log(div.offsetHeight); 还是1次重排吗？ Obviously not! 此时发生了4次重排！ 上文不是说浏览器有渲染队列优化机制吗？ 为什么会有4次？ 这和offsetLeft/Top/Width/Height有关 offsetTop、offsetLeft、offsetWidth、offsetHeight clientTop、clientLeft、clientWidth、clientHeight scrollTop、scrollLeft、scrollWidth、scrollHeight getComputedStyle()（IE中currentStyle） 这些会强制刷新队列要求样式修改任务立刻执行 因为浏览器并不确定在下面的代码中是否还有修改同样的样式，为了获取到当前正确的的即时值不得不立刻执行渲染队列触发重排！！！ 四.重绘与重排性能优化1.分离读写操作我们就可以对上面的代码进行优化 123456789div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px';//所有的读操作写在所有的写操作之后console.log(div.offsetLeft);console.log(div.offsetTop);console.log(div.offsetWidth);console.log(div.offsetHeight); 这样就仅仅发生1次重排了！ 2.样式集中改变还是我们最初修改样式的代码 1234div.style.left = '10px';div.style.top = '10px';div.style.width = '20px';div.style.height = '20px'; 虽然现代浏览器有渲染队列的优化机制，但是古董浏览器效率仍然底下，触发了4次重排 ，即便这样，我们仍然可以做出优化 ，我们需要cssText属性合并所有样式改变 1div.style.cssText = 'left:10px;top:10px;width:20px;height:20px;'; 这样只需要修改DOM一次一并处理，仅仅触发了1次重排 ，而且只用了一行代码 cssText会覆盖已有的行间样式如果想保留原有行间样式，这样做 12&gt; div.style.cssText += ';left:10px;';&gt; 除了cssText以外，我们还可以通过修改class类名来进行样式修改 1div.className = 'new-class'; 这种办法可维护性好，还可以帮助我们免除显示性代码，但是会消耗一点点的性能 3.缓存布局信息12div.style.left = div.offsetLeft + 1 + 'px';div.style.top = div.offsetTop + 1 + 'px'; 这种读操作完就执行写操作造成了2次重排缓存可以进行优化 1234var curLeft = div.offsetLeft;var curTop = div.offsetTop;div.style.left = curLeft + 1 + 'px';div.style.top = curTop + 1 + 'px'; 相当于是分离读写操作，优化为1次重排 4.元素批量操作现在我们想要向ul中循环添加大量li （如果ul还不存在，最好的办法是先循环添加li到ul，然后再把ul添加到文档，1次重排） 1234567var ul = document.getElementById('demo');for(var i = 0; i &lt; 1e5; i++)&#123; var li = document.createElement('li'); var text = document.createTextNode(i); li.appendChild(text); ul.appendChild(li);&#125; 我可以做出下面的优化 12345678910111213141516171819202122232425262728var ul = document.getElementById('demo');ul.style.display = 'none'; for(var i = 0; i &lt; 1e5; i++)&#123; var li = document.createElement('li'); var text = document.createTextNode(i); li.appendChild(text); ul.appendChild(li);&#125;ul.style.display = 'block';var ul = document.getElementById('demo');var frg = document.createDocumentFragment(); for(var i = 0; i &lt; 1e5; i++)&#123; var li = document.createElement('li'); var text = document.createTextNode(i); li.appendChild(text); frg.appendChild(li); &#125;ul.appendChild(frg); var ul = document.getElementById('demo');var clone = ul.cloneNode(true); for(var i = 0; i &lt; 1e5; i++)&#123; var li = document.createElement('li'); var text = document.createTextNode(i); li.appendChild(text); clone.appendChild(li); &#125;ul.parentNode.replaceChild(clone,ul); 上面的方法减少重绘和重排的原理很简单 元素脱离文档 改变样式 元素回归文档 而改变元素就分别使用了隐藏元素、文档碎片和克隆元素","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"RN中没有固定定位怎么办？","slug":"RN中没有固定定位怎么办？","date":"2019-08-07T04:04:01.000Z","updated":"2019-08-07T04:13:42.461Z","comments":true,"path":"passages/RN中没有固定定位怎么办？/","link":"","permalink":"http://yoursite.com/passages/RN中没有固定定位怎么办？/","excerpt":"","text":"如上图的底部新增按钮，要是放在web里那是相当简单，直接是用固定定位就行，但是在RN里是没有固定定位。 怎么解决? 方案一 绝对定位采用绝对定位，相对于最外层的定位在底部位置。 在部分安卓机上有问题，动态计算的高度，定位底部的高度有问题，导致底部按钮定位脱离了视野 方案二 flex布局如上图，头部导航 是固定的， 剩下的就是 组件（红色方框区域） 设置属性 flex:1 使它撑满剩余空间，这时候可以设置它为相对定位，然后底部那个按钮绝对定位，这样可行， 但是我们可以用flex一层一层撑开。 按钮底部空白的位置，不是定位出来的，其实是适应iphoneX组件的空间，忽略。 接下来只要把内部划成三块就行：tab导航 列表内容 底部按钮 。 列表内容和底部导航是由一个VIew 包着 和tab 导航同一层级的。所以这个View 设置flex:1. 到了最后一层，就是设置列表内容 flex:1 ， 底部按钮固定高度。这样根据flex布局的属性，底部按钮就被挤在 最下面这个位置了。 这个方法相对于直接用一层定位来，多了几层flex:1，但是省去了计算高度的工作，不存在安卓的兼容性，免去了样式爆炸的烦恼。 总结：最核心就是一点，一层层设置flex：1,把固定高度的挤在固定的地方就行。","categories":[],"tags":[{"name":"react-native","slug":"react-native","permalink":"http://yoursite.com/tags/react-native/"}]},{"title":"浅谈BFC原理及作用","slug":"浅谈BFC原理及作用","date":"2019-08-06T05:19:20.000Z","updated":"2019-08-06T05:21:31.540Z","comments":true,"path":"passages/浅谈BFC原理及作用/","link":"","permalink":"http://yoursite.com/passages/浅谈BFC原理及作用/","excerpt":"","text":"一. BFC的概念BFC 即 Block Formatting Contexts (块级格式化上下文)，它属于上述布局模式的流动模型。是W3C CSS2.1规范中的一个概念，决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。 具有BFC特性的元素可以看做是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没有的的一些特性。 通俗一点来讲，可以把BFC理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 二.BFC的形成条件只要元素满足下面任一条件即可触发BFC特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 三.BFC常见的作用1.组织外边距重叠例：margin塌陷问题：在标准文档流中，块级标签之间竖直方向的margin会以大的为准，这就是margin的塌陷现象。 可以用overflow：hidden产生bfc来解决。 123456789101112&lt;head&gt;div&#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt; ​ 因为两个div元素都处于同一个BFC容器下（这里指body元素），所以第一个div的下边距和第二个div的上边距发生了重叠，所以两个盒子之间距离只有100px，而不是200px。 首先这不是 CSS 的 bug，我们可以理解为一种规范，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 123456&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;p&gt;&lt;/p&gt;&lt;/div&gt; 123456789.container &#123; overflow: hidden;&#125;p &#123; width: 100px; height: 100px; background: lightblue; margin: 100px;&#125; ​ 2.包含浮动元素 例：高度塌陷问题，在通常情况下父元素的高度会被子元素撑开，而在这里因为其子元素为浮动元素所以父元素发生了高度坍塌，上下边界重合，这时就可以用BFC来清除浮动了。 123&lt;div style=\"border: 1px solid #000;\"&gt; &lt;div style=\"width: 100px;height: 100px;background: grey;float: left;\"&gt;&lt;/div&gt;&lt;/div&gt; 由于容器内元素浮动，脱离了文档流，所以容器只剩下2px的边距高度。如果触发容器的BFC，那么容器将会包裹浮动元素。 ​ 3、阻止元素被浮动元素覆盖 例：div浮动兄弟这该问题：由于左侧块级元素发生了浮动，所以和右侧未发生浮动的块级元素不在同一层内，所以会发生div遮挡问题。可以给右侧元素添加 overflow: hidden，触发BFC来解决遮挡问题。 我是一个左浮动的元素我是一个没有设置浮动,也没有触发 BFC 元素, width: 200px; height:200px; background: grey; 1这时候其实第二个元素有部分被浮动元素所覆盖，但是文本信息不会被浮动元素所覆盖，如果想避免元素被覆盖，可触发第二个元素的BFC特性，在第二个元素中加入overflow：hidden，就会变成： 我是一个左浮动的元素我是一个没有设置浮动,也没有触发 BFC 元素, width: 200px; height:200px; background: grey; ​ 这个方法可以用来实现两列自适应布局，效果不错，这时候左边的宽度固定，右边的内容自适应宽度。","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"media与screen的自适应网页布局","slug":"media与screen的自适应网页布局","date":"2019-08-06T05:06:24.000Z","updated":"2019-08-06T05:16:40.022Z","comments":true,"path":"passages/media与screen的自适应网页布局/","link":"","permalink":"http://yoursite.com/passages/media与screen的自适应网页布局/","excerpt":"","text":"1：设置Meta标签首先我们在使用Media的时候需要先设置下面这段代码，来兼容移动设备的展示效果： 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\"&gt; 这段代码的几个参数解释： width = device-width：宽度等于当前设备的宽度 height = device-height：高度等于当前设备的高度 initial-scale：初始的缩放比例（默认设置为1.0） minimum-scale：允许用户缩放到的最小比例（默认设置为1.0） maximum-scale：允许用户缩放到的最大比例（默认设置为1.0） user-scalable：用户是否可以手动缩放（默认设置为no，因为我们不希望用户放大缩小页面） 2：加载兼容文件JS因为IE8既不支持HTML5也不支持CSS3 Media，所以我们需要加载两个JS文件，来保证我们的代码实现兼容效果： 1234&lt;!--[if lt IE 9]&gt;&lt;script src=\"https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js\"&gt;&lt;/script&gt;&lt;script src=\"https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js\"&gt;&lt;/script&gt;&lt;![endif]--&gt; 3：设置IE渲染方式默认为最高(这部分可以选择添加也可以不添加)现在有很多人的IE浏览器都升级到IE9以上了，所以这个时候就有又很多诡异的事情发生了，例如现在是IE9的浏览器，但是浏览器的文档模式却是IE8: 为了防止这种情况，我们需要下面这段代码来让IE的文档模式永远都是最新的： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; （如果想使用固定的IE版本，可写成： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=EmulateIE9\"&gt; ） 除此之外，还有一个更好的写法： 1&lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge，chrome=1\"&gt; 怎么这段代码后面加了一个chrome=1，这个Google Chrome Frame（谷歌内嵌浏览器框架GCF），如果有的用户电脑里面装了这个chrome的插件，就可以让电脑里面的IE不管是哪个版本的都可以使用Webkit引擎及V8引擎进行排版及运算，如果用户没装这个插件，那这段代码就会让IE以最高的文档模式展现效果。 CSS3 Media写法我们先来看下下面这段代码，估计很多人在响应式的网站CSS很经常看到类似下面的这段代码： 12345@media screen and (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; 这个应该算是一个media的一个标准写法，上面这段CSS代码意思是：当页面小于960px的时候执行它下面的CSS. 应该有人会发现上面这段代码里面有个screen，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时，你可以直接这样写： 12345@media (max-width: 960px)&#123; body&#123; background: #000; &#125;&#125; CSS2 Media用法其实并不是只有CSS3才支持Media的用法，早在CSS2开始就已经支持Media，具体用法，就是在HTML页面的head标签中插入如下的一段代码： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen\" href=\"style.css\"&gt; 上面其实是CSS2实现的衬线用法，那CSS2的media难道就只能支持上面这一个功能吗？答案当然不是，他还有很多用法。 例如我们想知道现在的移动设备是不是纵向放置的显示屏，可以这样写： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (orientation:portrait)\" href=\"style.css\"&gt; 我们把第一段的代码也用CSS2来实现，让它一样可以让页面宽度小于960的执行指定的样式文件： 1&lt;link rel=\"stylesheet\" type=\"text/css\" media=\"screen and (max-width:960px)\" href=\"style.css\"&gt; 既然CSS2可以实现CSS的这个效果为什么不用这个方法呢，很多人应该会问，但是上面这个方法，最大的弊端是他会增加页面http的请求次数，增加了页面负担，我们用CSS3把样式都写在一个文件里面才是最佳的方法。 回归CSS3 Media上面我们大概讲了下CSS2的媒体查询用法，现在我们重新回到CSS3的媒体查询，在第一段代码上面我用的是小于960px的尺寸的写法，那现在我们来实现等于960px尺寸的代码： 12345@media screen and (max-device-width:960px)&#123; body&#123; background:red; &#125;&#125; 然后就是当浏览器尺寸大于960px时候的代码了： 12345@media screen and (min-width:960px)&#123; body&#123; background:orange; &#125;&#125; 我们还可以混合使用上面的用法： 12345@media screen and (min-width:960px) and (max-width:1200px)&#123; body&#123; background:yellow; &#125;&#125; 上面的这段代码的意思是当页面宽度大于960px小于1200px的时候执行下面的CSS。 Media所有参数汇总以上就是我们最常需要用到的媒体查询器的三个特性，大于，等于，小于的写法。媒体查询器的全部功能肯定不止这三个功能，下面是我总结的它的一些参数用法解释： width:浏览器可视宽度。 height:浏览器可视高度。 device-width:设备屏幕的宽度。 device-height:设备屏幕的高度。 orientation:检测设备目前处于横向还是纵向状态。 aspect-ratio:检测浏览器可视宽度和高度的比例。(例如：aspect-ratio:16/9) device-aspect-ratio:检测设备的宽度和高度的比例。 color:检测颜色的位数。（例如：min-color:32就会检测设备是否拥有32位颜色） color-index:检查设备颜色索引表中的颜色，他的值不能是负数。 monochrome:检测单色楨缓冲区域中的每个像素的位数。（这个太高级，估计咱很少会用的到） resolution:检测屏幕或打印机的分辨率。(例如：min-resolution:300dpi或min-resolution:118dpcm)。 grid：检测输出的设备是网格的还是位图设备。 注意下顺序，如果你把@media (min-width: 768px)写在了下面那么很悲剧， @media (min-width: 1200){ //&gt;=1200的设备 } @media (min-width: 992px){ //&gt;=992的设备 } @media (min-width: 768px){ //&gt;=768的设备 } 因为如果是1440,由于1440&gt;768那么你的1200就会失效。 所以我们用min-width时，小的放上面大的在下面，同理如果是用max-width那么就是大的在上面，小的在下面 @media (max-width: 1199){ //&lt;=1199的设备 } @media (max-width: 991px){ //&lt;=991的设备 } @media (max-width: 767px){ //&lt;=768的设备 } 1280分辨率以上（大于1200px） 123@media screen and (min-width:1200px)&#123; #page&#123; width: 1100px; &#125;#content,.div1&#123;width: 730px;&#125;#secondary&#123;width:310px&#125;&#125; 1100分辨率（大于960px，小于1199px） 123@media screen and (min-width: 960px) and (max-width: 1199px) &#123; #page&#123; width: 960px; &#125;#content,.div1&#123;width: 650px;&#125;#secondary&#123;width:250px&#125;select&#123;max-width:200px&#125;&#125; 880分辨率（大于768px，小于959px） 123@media screen and (min-width: 768px) and (max-width: 959px) &#123; #page&#123; width: 900px; &#125;#content,.div1&#123;width: 620px;&#125;#secondary&#123;width:220px&#125;select&#123;max-width:180px&#125;&#125; 720分辨率（大于480px，小于767px） 123@media only screen and (min-width: 480px) and (max-width: 767px)&#123; #page&#123; width: 450px; &#125;#content,.div1&#123;width: 420px;position: relative; &#125;#secondary&#123;display:none&#125;#access&#123;width: 450px; &#125;#access a &#123;padding-right:5px&#125;#access a img&#123;display:none&#125;#rss&#123;display:none&#125;#branding #s&#123;display:none&#125;&#125; 440分辨率以下（小于479px） 123@media only screen and (max-width: 479px) &#123; #page&#123; width: 300px; &#125;#content,.div1&#123;width: 300px;&#125;#secondary&#123;display:none&#125;#access&#123;width: 330px;&#125; #access a &#123;padding-right:10px;padding-left:10px&#125;#access a img&#123;display:none&#125;#rss&#123;display:none&#125;#branding #s&#123;display:none&#125;#access ul ul a&#123;width:100px&#125;&#125; 12345/* 竖屏 */@media screen and (orientation: portrait) and (max-width: 720px) &#123; 对应样式 &#125;/* 横屏 */@media screen and (orientation: landscape) &#123; 对应样式 &#125; 上面的代码中用到了screen ，他的意思是在告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。但是目前我发现很多网站都会直接省略screen,因为你的网站可能不需要考虑用户去打印时。 PC端按屏幕宽度大小排序 分辨率 比例 | 设备尺寸 1024500 （8.9寸）1024768 （比例4：3 | 10.4寸、12.1寸、14.1寸、15寸; ）1280800（16：10 |15.4寸）12801024(比例：5：4 | 14.1寸、15.0寸)1280854(比例：15：10 | 15.2）1366768 (比例：16：9 | 不常见）1440900 （16：10 17寸 仅苹果用）14401050（比例：5：4 | 14.1寸、15.0寸）16001024（14：9 不常见）16001200 （4：3 | 15、16.1）16801050（16：10 | 15.4寸、20.0寸）19201200 (23寸） 通过上面的电脑屏蔽及尺寸的例表上我们得到了几个宽度1024 1280 1366 1440 1680 1920 CSS代码 @media (min-width: 1024px){ body{font-size: 18px}} /&gt;=1024的设备/@media (min-width: 1100px) { body{font-size: 20px}} /&gt;=1024的设备/@media (min-width: 1280px) { body{font-size: 22px;}}@media (min-width: 1366px) { body{font-size: 24px;}}@media (min-width: 1440px) { body{font-size: 25px !important;}}@media (min-width: 1680px) { body{font-size: 28px;}}@media (min-width: 1920px) { body{font-size: 33px;}}","categories":[],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"jQuery复习","slug":"jQuery复习","date":"2019-05-16T05:24:23.000Z","updated":"2019-05-16T05:28:15.229Z","comments":true,"path":"passages/jQuery复习/","link":"","permalink":"http://yoursite.com/passages/jQuery复习/","excerpt":"","text":"一.选择器1.1 基本选择器#id id选择器 12&lt;div id=&apos;one&apos;&gt;AAA&lt;/div&gt;$(&quot;#one&quot;).css(&quot;background-color&quot;,&quot;red&quot;); element 标签选择器 123&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;$(\"div\").css(\"background-color\",\"yellow\"); .class 类选择器 12&lt;div class='mini'&gt;AAA&lt;/div&gt;$(\".mini\").css(\"background-color\",\"blue\"); * 所有元素 1234&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;bbb&lt;/span&gt;&lt;h1&gt;ccc&lt;/h1&gt;$(\"*\").css(\"background-color\",\"green\"); s1,s2,… 多选择器，将多个选择器的结果添加一个数组中 1234&lt;div class='mini'&gt;AAA&lt;/div&gt;&lt;div id='two'&gt;BBB&lt;/div&gt;&lt;span&gt;CCC&lt;/span&gt;$(\"span,#two,.mini\").css(\"background-color\",\"brown\"); 1.2 层级选择器A B ，获得A元素内部所有的B元素 1234&lt;body&gt; &lt;div class='mini'&gt;AAA&lt;/div&gt;&lt;/body&gt;$(\"body div\").css(\"background-color\", \"red\"); A &gt; B ，获得A元素内部所有的B子元素 123456&lt;body&gt; &lt;div&gt;AAA&lt;/div&gt; &lt;div&gt;BBB&lt;/div&gt; &lt;span&gt;CCC&lt;/span&gt;&lt;/body&gt;$(\"body &gt; div\").css(\"background-color\", \"yellow\"); A + B ，获得A元素后面的第一个兄弟B 123&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;$(\"div + div\").css(\"background-color\", \"blue\"); A ~ B ，获得A元素后面的所有的兄弟B 123456&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;BBB&lt;/span&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;&lt;div&gt;eee&lt;/div&gt;$(&quot;div ~ span&quot;).css(&quot;background-color&quot;, &quot;green&quot;); A.siblings(“B”)，A的所有是B的兄弟 12345&lt;span&gt;BBB&lt;/span&gt;&lt;div&gt;AAA&lt;/div&gt;&lt;span&gt;ccc&lt;/span&gt;&lt;span&gt;ddd&lt;/span&gt;$(\"div\").siblings(\"span\").css(\"background-color\", \"brown\"); 1.3 基本过滤选择器 过滤选择器都有 : :first 选中第一个元素 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:first\").css(\"background-color\", \"red\"); :last 选中最后一个 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:last\").css(\"background-color\", \"yellow\"); :eq(index) 获得指定索引(从0开始) 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:eq(2)\").css(\"background-color\", \"blue\"); :gt(index) 大于 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:gt(1)\").css(\"background-color\", \"red\"); :lt(index) 小于 1234&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;$(\"div:lt(1)\").css(\"background-color\", \"green\"); :animated 获得所有在动画的元素 1$(\":animated\").css(\"background-color\", \"green\"); :not(selector) 去除所有与给定选择器匹配的元素 1234&lt;div class=\"one\"&gt;AAA&lt;/div&gt;&lt;div class=\"two\"&gt;BBB&lt;/div&gt;&lt;div class=\"three\"&gt;CCC&lt;/div&gt; $(\"div:not('.one')\").css(\"background-color\", \"blue\"); :header 获得所有标题元素 例如：… 1234&lt;h1&gt;h1&lt;/h1&gt;&lt;h2&gt;h2&lt;/h2&gt;&lt;h3&gt;h3&lt;/h3&gt;$(\":header\").css(\"background-color\", \"green\").css(\"font-size\",\"30px\"); :even 偶数，从 0 开始计数 12345&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:even\").css(\"background-color\", \"brown\"); :odd 奇数 12345&lt;div&gt;AAA&lt;/div&gt;&lt;div&gt;BBB&lt;/div&gt;&lt;div&gt;CCC&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:odd\").css(\"background-color\", \"yellow\"); 1.4 内容过滤选择器 均要加冒号 :empty 当前元素是否为空（是否有标签体–子元素、文本） 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:empty\").css(\"background-color\",\"yellow\"); :has(…) 当前元素，是否含有指定的子元素 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:has('span')\").css(\"background-color\",\"blue\"); :parent 当前元素是否是父元素（自己是否拥有子元素） 1234567&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div&gt;DDD&lt;/div&gt;$(\"div:parent\").css(\"background-color\",\"green\"); :contains( text ) 标签体是否含有指定的文本 1234&lt;div&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div&gt;ddd&lt;/div&gt;$(\"div:contains('d')\").css(\"background-color\",\"red\"); 1.5 可见性过滤选择器:hidden 隐藏。特指 &lt;xxx style=&quot;display:none;&quot;&gt; 或者 &lt;input type=&quot;hidden&quot;&gt; 1234&lt;div style=\"display:none\"&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;input type=\"hidden\"&gt;$(\"div:hidden\").show(1000).css(\"background-color\",\"yellow\"); :visible 可见（默认） 1234&lt;div style=\"display:none\"&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;input type=\"hidden\"&gt;$(\"div:visible\").css(\"background-color\",\"red\"); 1.6 属性选择器[属性名] 获得指定的属性名的元素 1234&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div&gt;ddd&lt;/div&gt;$(\"div[title]\").css(\"background-color\",\"red\"); [属性名=值] 获得属性名 等于 指定值的 的元素 1234&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div&gt;bbb&lt;/div&gt;&lt;div title='test'&gt;ddd&lt;/div&gt;$(\"div[title='test']\").css(\"background-color\",\"blue\"); [属性名!=值] 获得属性名 不等于 指定值的 的元素 123&lt;div title='aaa'&gt;aaa&lt;/div&gt;&lt;div title='test'&gt;ddd&lt;/div&gt; $(\"div[title!='test']\").css(\"background-color\",\"yellow\"); [as1][as2][as3]…. 复合选择器，多个条件同时成立。类似 where …and…and 1234&lt;div title='aes' id=\"aaa\"&gt;aaa&lt;/div&gt;&lt;div &gt;bbb&lt;/div&gt;&lt;div title='test' id='ddd'&gt;ddd&lt;/div&gt;$(\"div[id][title*='es']\").css(\"background-color\",\"red\"); [属性名^=值] 获得以属性值 开头 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title^='te']\").css(\"background-color\",\"green\"); [属性名$=值] 获得以属性值 结尾 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title$='est']\").css(\"background-color\",\"brown\"); [属性名*=值] 获得 含有属性值 的元素 1234&lt;div title='test'&gt;aaa&lt;/div&gt;&lt;div title='teve'&gt;bbb&lt;/div&gt;&lt;div title='txt'&gt;ddd&lt;/div&gt;$(\"div[title*='es']\").css(\"background-color\",\"yellow\"); 1.7 元素过滤选择器:nth-child(n) 第n个孩子(从1开始) 1234567&lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"body :nth-child(2)\").css(\"background-color\",\"yellow\"); :first-child 第一个孩子 12345678910111213&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;//注意空格的区别$(\"div :first-chlid\").css(\"background-color\",\"yellow\");//div里面的元素的第一个$(\"div:first-chlid\").css(\"background-color\",\"yellow\");//div的第一个 :last-child 最后一个孩子 12345678910111213&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;//注意空格的区别$(\"div :last-chlid\").css(\"background-color\",\"yellow\");//div里面的元素的最后一个$(\"div:last-chlid\").css(\"background-color\",\"yellow\");//div的最后一个 :only-child 仅有一个孩子 123456789101112&lt;body&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"div :last-chlid\").css(\"background-color\",\"yellow\"); 1.8 表单过滤选择器:input 所有的表单元素。&lt;input&gt; / &lt;select&gt; / &lt;textarea&gt; / &lt;button&gt; 12345&lt;input&gt;&lt;select&gt;&lt;option&gt;&lt;/option&gt;&lt;/select&gt;&lt;textarea&gt;&lt;/textarea&gt;&lt;button&gt;&lt;/button&gt;$(\":input\").css(\"background-color\",\"yellow\"); :text 文本框&lt;input type=&quot;text&quot;&gt; 12&lt;input type=\"text\"&gt;$(\":text\").css(\"background-color\",\"yellow\"); :password 密码框&lt;input type=&quot; password &quot;&gt; 12&lt;input type=\"password\"&gt;$(\":password\").css(\"background-color\",\"yellow\"); :radio 单选&lt;input type=&quot;radio&quot;&gt; 1234567&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;苹果 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;桃子 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;香蕉 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;梨 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;其它 &lt;/label&gt; &lt;input type=\"radio\"&gt;$(\":radio\").css(\"background-color\",\"yellow\"); :checkbox 复选框&lt;input type=&quot;checkbox&quot;&gt; 123456789&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"今日话题\" /&gt;今日话题 &lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"视觉焦点\" /&gt;视觉焦点&lt;/p&gt;&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"财经\" /&gt;财经&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"汽车\" /&gt;汽车&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"科技\" /&gt;科技&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"房产\" /&gt;房产&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"旅游\" /&gt;旅游&lt;/p&gt;&lt;input type=\"checkbox\"&gt;$(\":checkbox\").css(\"background-color\",\"yellow\"); :submit 提交按钮&lt;input type=&quot;submit&quot;&gt; 12&lt;input type=\"submit\"&gt;$(\":submit\").css(\"background-color\",\"yellow\"); :image 图片按钮&lt;input type=&quot;image&quot; src=&quot;&quot;&gt; 12&lt;input type=\"image\" src=\"\"&gt;$(\":image\").css(\"background-color\",\"yellow\"); :reset 重置按钮&lt;input type=&quot;reset&quot;&gt; 12&lt;input type=&quot;reset&quot; src=&quot;&quot;&gt;$(&quot;:reset&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); :file 文件上传&lt;input type=&quot;file&quot;&gt; 12&lt;input type=\"file\"&gt;$(\":file\").css(\"background-color\",\"yellow\"); :hidden 隐藏域&lt;input type=&quot;hidden&quot;&gt; ,还可以获得&lt;xxx style=&quot;display:none&quot;&gt; 123&lt;input type=\"hidden\"&gt;&lt;div style=\"display:none\"&gt;&lt;/div&gt;$(\":hidden\").css(\"background-color\",\"yellow\"); :button 所有普通按钮。&lt;button &gt; 或 &lt;input type=&quot;button&quot;&gt; 123&lt;button &gt;button&lt;/button&gt;&lt;input type=\"button\"&gt;$(\":button\").css(\"background-color\",\"yellow\"); select 下拉列表 (没有:号） 1234567&lt;select&gt; &lt;option value =\"volvo\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt;$(\"select\").css(\"background-color\",\"yellow\"); textarea 多行文本框（没有:号） 12&lt;textarea&gt;&lt;/textarea&gt;$(\"textarea\").css(\"background-color\",\"yellow\"); 1.9 表单独享属性过滤选择器:enabled 可用 123&lt;input type='text'&gt;&lt;input type='text' disabled=\"disabled\"&gt;$(\"input:enabled\").val(\"aaaa\"); :disabled 不可用。&lt;xxx disabled=&quot;disabled&quot;&gt; 或&lt;xxx disabled=&quot;&quot;&gt; 或&lt;xxx disabled&gt; 12345&lt;input type='text'&gt;&lt;input type='text' disable=\"\"&gt;&lt;input type='text' disable&gt;&lt;input type='text' disabled=\"disabled\"&gt;$(\"input:disabled\").val(\"bbbb\"); :checked 选中（单选框radio、复选框 checkbox） 12345678910111213141516&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"今日话题\" /&gt;今日话题 &lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"视觉焦点\" /&gt;视觉焦点&lt;/p&gt;&lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"财经\" /&gt;财经&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"汽车\" checked=\"\"/&gt;汽车&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"科技\" /&gt;科技&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"房产\" /&gt;房产&lt;/p&gt; &lt;p&gt;&lt;input type=\"checkbox\" name=\"category\" value=\"旅游\" /&gt;旅游&lt;/p&gt;&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" checked=\"\"/&gt;苹果 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;桃子 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;香蕉 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;梨 &lt;/label&gt; &lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" /&gt;其它 &lt;/label&gt; $(\":checked\").css(\"background-color\",\"yellow\"); :selected 选择（下拉列表 select option） 1234567&lt;select&gt; &lt;option value =\"volvo\" selected=\"\"&gt;Volvo&lt;/option&gt; &lt;option value =\"saab\"&gt;Saab&lt;/option&gt; &lt;option value=\"opel\"&gt;Opel&lt;/option&gt; &lt;option value=\"audi\"&gt;Audi&lt;/option&gt;&lt;/select&gt;$(\"selected\").css(\"background-color\",\"yellow\"); 二.jQuery属性和CSS2.1 属性操作attr() 设置单个属性 12&lt;img title=\"\"&gt;$('img').attr('title','哎哟，不错哦'); 设置多个属性 123456&lt;img title=\"\" alt=\"\" &gt;$('img').attr(&#123; title:'image', alt:'缺省', style:'opacity:.5'&#125;); 获取属性 12&lt;img title=\"images\" alt=\"\" &gt;var oTitle = $('img').attr('title'); removeattr() 移除属性 12&lt;img title=\"images\" alt=\"\" &gt;$('img').removeAttr('title'); prop() 在jQuery1.6之后，对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。 设置和获取属性 12345&lt;label&gt;&lt;input name=\"Fruit\" type=\"radio\" value=\"\" checked=\"\"/&gt;苹果 &lt;/label&gt; // 设置属性$(':checked').prop('checked',true);// 获取属性$(':checked').prop('checked');// 返回true或者false val()/text()/html() 123$obj.val() 获取或者设置表单元素的value属性的值$obj.html() 对应innerHTML$obj.text() 对应innerText/textContent，处理了浏览器的兼容性。注意点：如果获取jquery对象text属性的时候jquery对象是一个数组，那么此时会把数组中所有元素的文本都获取到 2.2 CSS操作css() css(name) 获得指定名称的css值css(name ,value) 设置一对值css(prop) 设置一组值 操作单个样式 12&lt;div&gt;&lt;/div&gt;$(\"div\").css(\"border\",\"1px solid red\"); 操作多个样式 1234567&lt;div&gt;&lt;/div&gt;$(\"div\").css(&#123; \"width\":\"300px\", \"height\":\"50px\", \"font-size\":\"60px\", \"color\":\"blue\"&#125;); 获取样式 12&lt;div style='background-color:'red'&gt;&lt;/div&gt;$('div').css('background-color'); 设置样式操作的时候，如果是多个元素，那么给所有的元素设置相同的值 获取样式操作的时候，如果是多个元素，那么只会返回第一个元素的值。 class类操作 addClass(“A”) 追加一个类removeClass(“A”) 将指定类移除toggleClass(“A”) 如果有A将移除，如果没有将添加。hasClass(“A”) 用于判断是否含有指定样式，返回值为true false 三. jQuery尺寸和位置操作3.1 CSS尺寸 height() 获得 或 设置 高度 //不包括内边距、边框和外边距width()获得 或 设置 宽度 12345&lt;div style=\"height:100px;width:110px\"&gt;&lt;/div&gt;$(\"div\").css(\"border\",\"1px solid red\");alert($(\"div\").height()); //数字类型alert($(\"div\").width());$(\"div\").height(\"300px\"); //设置高度，值可以是数字也可以是字符串 获取可视区宽高度 1234// 获取可视区宽度$(window).width();// 获取可视区高度$(window).height(); css获取到的宽高是带 px 的,需要数值则需要用parseInt()转换 css设置样式可不加px 3.2 innerWidth/outerWidth innerWidth()/innerHeight() 方法返回元素的宽度/高度（包括内边距）。 —&gt;clientWidthouterWidth()/outerHeight() 方法返回元素的宽度/高度（包括内边距和边框）。 —&gt;offsetWidthouterWidth(true)/outerHeight(true) 方法返回元素的宽度/高度（包括内边距、边框和外边距）。 3.3 scrollTop与scrollLeft获取页面滚出的位置 1234// 获取页面被滚出的高度$(window).scrollTop();// 获取页面被滚出的宽度$(window).scrollLeft(); 3.4 offset方法与position方法offset() offset方法获取元素距离document的位置 1234// 获取元素距离document的位置,返回值为对象：&#123;left:100, top:100&#125;$(selector).offset();//设置位置$(\"div\").offset(&#123;\"top\":0,\"left\":0&#125;);//不用加px position方法获取的是元素距离第一个定位了的父元素(offsetParent)的位置 获取相对于其最近的有定位的父元素的位置。 12// position仅用于获取当前元素相对于父元素的位置，不可以设置。如果非要设置，需要引入jquery-ui.js$(selector).position(); 四.jQuery文档处理4.1 创建节点1$('&lt;span&gt;这是一个span元素&lt;/span&gt;'); 4.2 内部插入(不可重复插入)第一种方式 123456789101112131415A.append(B) 将B插入到A的内部后面（之后的串联操作，操作A） &lt;A&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;B&gt;&lt;/B&gt; &lt;A&gt; A.prepend(B) 将B插入到A的内部前面 &lt;A&gt; &lt;B&gt;&lt;/B&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;A&gt; 第二种方式 12345678910111213A.appendTo(B) 将A插入到B的内部后面 （之后的串联操作，操作A） &lt;A&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;C&gt;&lt;/C&gt; &lt;B&gt;&lt;/B&gt; &lt;A&gt;A.prependTo(B) 将A插入到B的内部前面 &lt;B&gt; &lt;A&gt;&lt;/A&gt; .... &lt;B&gt; 4.3 外部插入第一种方法 12345678A.insertAfter(B) , 将A插入到B后面（同级） ...... &lt;B&gt;&lt;/B&gt; &lt;A&gt;&lt;/A&gt;A.insertBefore(B) 将A插入到B前面 &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt; ...... 第二种方法 12345678A.after(B) , 将B插入到A后面（同级） ...... &lt;A&gt;&lt;/A&gt; &lt;B&gt;&lt;/B&gt;A.before(B) ，将B插入到A前面 &lt;B&gt;&lt;/B&gt; &lt;A&gt;&lt;/A&gt; ...... 4.4 删除节点 empty() 清空标签体（清空文本节点和子节点）,自身保留(清理门户),会清除子元素上绑定的内容remove() 删除当前对象。如果之后再使用，元素本身保留，绑定事件 或 绑定数据 都会被移除detach() 删除当前对象。如果之后再使用，元素本身保留，绑定事件 或 绑定数据 都保留 注意:$(‘div’).html(‘’);// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。 4.5 复制节点clone(even) even ：指示事件处理函数是否会被复制。V1.5以上版本默认值是：false 1234&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;$(\"body\").append($('div').clone(true)); 4.6 替换节点A.replaceWith(B) ，使用B将A替换掉 12&lt;p&gt;p&lt;/p&gt;$(\"p\").replaceWith(\"&lt;a&gt;xxxx&lt;/a&gt;\"); A.replaceAll(B) ，使用A替换B 1234&lt;p&gt;p&lt;/p&gt;&lt;p&gt;p&lt;/p&gt;&lt;p&gt;p&lt;/p&gt;$(\"&lt;a&gt;ssss&lt;/a&gt;\").replaceAll(\"p\");","categories":[],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"http://yoursite.com/tags/jQuery/"}]},{"title":"Javascript冒泡事件机制","slug":"Javascript冒泡事件机制","date":"2017-11-24T13:41:43.000Z","updated":"2019-04-21T13:52:47.236Z","comments":true,"path":"passages/Javascript冒泡事件机制/","link":"","permalink":"http://yoursite.com/passages/Javascript冒泡事件机制/","excerpt":"","text":"Javascript冒泡事件机制1.事件在浏览器端的应用平台，基本是都是用事件来驱动的 事件：某个动作发生，然后做出相应的动作 浏览器中，事件表示某些事情发生的信号。 2.冒泡机制首先，什么是冒泡？ 想象一下，当水底有气泡的时候，气泡是从最底部由深向浅向上上升，在这过程，气泡会经过不同深度的水。 联想：气泡就相当于事件，水就如同整个Dom树，事件从Dom树的底部层层向上传递，直到达到Dom的根节点 案例分析我们写一个HTML页面，其中包含三个Dom元素，div外，div中，span内，其中外包含中包含内。 1234567&lt;body id=\"body\"&gt; &lt;div id=\"box1\"&gt; &lt;div id=\"box2\"&gt; &lt;sapn id=\"span\"&gt;我是span&lt;/sapn&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 12345678910111213141516171819#box1 &#123; width: 300px; height: 300px; background-color: skyblue;&#125;#box2 &#123; width: 200px; height: 200px; background-color: pink;&#125;#span &#123; display: inline-block; width: 100px; height: 100px; background-color: yellow;&#125;#body &#123; background-color: rgb(0, 252, 134);&#125; 界面如下： 接下来我们实现如下功能： body添加click事件监听，当body捕获到event事件时，输出事件发生的事件和触发事件的节点信息 12345678&lt;script&gt; window.onload = function() &#123; document.getElementById(\"body\").addEventListener(\"click\",eventHandler); &#125; function eventHandler(event) &#123; console.log(\"时间：\"+new Date(event.timeStamp)+\" 产生事件的节点：\" + event.target.id +\" 当前节点：\"+event.currentTarget.id); &#125; &lt;/script&gt; 我们依次点击“这是span”，div中，div外和body，得到以下信息 我们可以得出结论： 无论是body，body的子元素div外，还是div外的子元素div中，以及span，当这些被点击时，会产生click事件，并且最后都会传到body被捕获，接着再调用相关处理时间函数。 示意图如下： 事件在传递过程中会传递以下信息： 事件发生时间+事件发声地点+事件类型+事件当前处理者+其他 3.终止事件冒泡现在，我们这样，当点击各自的部分时，我们让他们各自产生提示信息 12345678910111213&lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; console.log(\"我是最外层div。\"); &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; console.log(\"我是中间div。\"); &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; console.log(\"我是span。\"); &#125;); &#125; &lt;/script&gt; 当我们点击span时，会弹出以下信息 显示我们并不想要这样，我们只想点击哪部分就显示哪部分的提示。那么为什么会这样呢？原因就在于冒泡的机制，当我们点击span时，span会将事件冒泡给div中，然后再冒泡给div外。当冒泡到相应的元素是会触发响应函数，在从内向外的传递过程中，依次打印了各自的信息。 原理清楚了，那么该如何阻止事件的冒泡呢？ 方法一我们想象一下，一个气泡正从水底向上冒，现在我们在水中，我们不想让他向上冒了怎么办？ 对，把他扎破。没有了气泡自然也就不会有冒泡了。 类似，在某个节点中，如果不想让他处理向上传递，我们可以终止事件的冒泡： event.stopPropagation() 这个函数可以终止事件的分发，使之不会向上层传递 我们修改script的内容 12345678910111213141516&lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; console.log(\"我是最外层div。\"); event.stopPropagation(); &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; console.log(\"我是中间div。\"); event.stopPropagation(); &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; console.log(\"我是span。\"); event.stopPropagation(); &#125;); &#125; &lt;/script&gt; 当我们再次点击span时，只会有span提示。 方法二讲方法二之前，我们先分清最初触发事件的节点引用和当前处理事件节点的引用 最初触发事件的节点引用:即事件产生的节点 当前处理事件节点的引用 ：即处理当前事件的节点 事件产生的节点只有一个，而在传递的过程中，节点都可以处理事件。那么我们可以设置： 节点只处理自己触发的事件,不是自己产生的事件就不处理。 event.target 引用了产生此event对象的dom 节点，而event.currrentTarget 则引用了当前处理节点，我们可以通过对比这两个target 是否相等来决定是否处理事件。 例如：当span 点击事件，产生一个event 事件对象，event.target 指向了span元素，span处理此事件时，event.currentTarget 指向的也是span元素，这时判断两者相等，则执行相应的处理函数。而事件传递给 div中 的时候，event.currentTarget变成 div中，这时候判断二者不相等，即事件不是div中本身产生的，就不作响应处理逻辑。 因此我们修改script代码： 1234567891011121314151617181920212223 &lt;script&gt; window.onload = function() &#123; document.getElementById(\"box1\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是最外层div。\"); &#125; &#125;); document.getElementById(\"box2\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是中间div。\"); &#125; &#125;); document.getElementById(\"span\").addEventListener(\"click\",function(event)&#123; if(event.target == event.currentTarget) &#123; console.log(\"我是span。\"); &#125; &#125;);&#125; &lt;/script&gt; 同样可以达到我们想要的效果 那么这两个方法有什么不同呢？ 比较： 方法一在于取消事件冒泡，即当某些节点取消冒泡后，事件不会再传递； 方法二在于不阻止冒泡，过滤需要处理的事件，事件处理后还会继续传递； 方法一缺点： 为了实现点击特定的元素显示对应的信息，方法一要求每个元素的子元素也必须终止事件的冒泡传递 。 比如，当span 元素的处理函数没有执行冒泡终止，则事件会传到div中上，这样会造成div中 的提示信息 方法二缺点： 增加了代码冗余和逻辑上的复杂度 当有几十个，几百个，那么要求每一层都要有if(event.target == event.currentTarget) 方法改进我们看方法二， 方法二的原理是 元素收到事件后，判断事件是否符合要求，然后做相应的处理，然后事件继续冒泡往上传递； 既然事件是冒泡传递的，那可不可以让某个父节点统一处理事件，通过判断事件的发生地（即事件产生的节点），然后做出相应的处理呢？ 答案是可以的，下面通过给body 元素添加事件监听，然后通过判断event.target 然后对不同的target产生不同的行为。 12345678910111213141516171819&lt;script&gt; window.onload = function() &#123; document.getElementById(\"body\").addEventListener(\"click\",eventPerformed); &#125; function eventPerformed(event) &#123; var target = event.target; switch (target.id) &#123; case \"span\": console.log(\"我是span。\"); break; case \"box1\": console.log(\"我是外层div。\"); break; case \"box2\": console.log(\"我是中间div。\"); break; &#125; &#125; &lt;/script&gt; 结果是点击谁谁会提示！ 我们把本来每个元素都要有的处理函数，都交给了其祖父节点body 元素来完成了，也就是说，span,div中,div外 将自己的响应逻辑委托给body，让它来完成相应逻辑，自己不实现相应逻辑，这个模式，就是所谓的事件委托。 如图 本篇博客参考 https://blog.csdn.net/u010349169/article/details/23927347","categories":[],"tags":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/tags/JS/"}]},{"title":"TODOS案例（二）","slug":"TODOS案例（二）","date":"2017-11-19T13:52:50.000Z","updated":"2019-04-17T14:21:18.236Z","comments":true,"path":"passages/TODOS案例（二）/","link":"","permalink":"http://yoursite.com/passages/TODOS案例（二）/","excerpt":"","text":"TODOS案例（二）界面样式设计上一期我们简单对页面元素进行了添加，本篇将对界面样式进行设置和布局。 最终呈现的效果如下图 先对input框进行调节，给input框一个边框以及颜色，内外边距统一为20rpx，边框圆角统一为5rpx，盒子阴影设置为5rpx模糊程度。 考虑到内部图片和输入框的横向排列，我们采用flex布局方式，给.search的display设为flex，为了使内部组件在水平线上对齐，设置align-item为center 代码如下 123456789.search &#123; border: 1rpx solid #e0e0e0; margin: 20rpx; padding: 20rpx; border-radius: 5rpx; box-shadow: 0 0 5rpx #e0e0e0; display: flex; align-items: center;&#125; 再设置添加图片大小以及设置和右侧文本框的距离： 12345.search image &#123; width: 45rpx; height: 45rpx; margin-right: 20rpx;&#125; 这样input部分调整完成！！ 下面开始调整中部的样式，我们同样给边框设置相同样式！ 1234567.todos &#123; border: 1rpx solid #e0e0e0; margin: 20rpx; padding: 20rpx; border-radius: 5rpx; box-shadow: 0 0 5rpx #e0e0e0;&#125; 在对内部item组件进行调整，并且同样采取flex布局，两端的icon我们在属性里设置为30大小，中间文本框采用flex自动撑开 123456789101112.todos .item &#123; padding: 20rpx; border-bottom: 1rpx solid #e0e0e0; display: flex; align-items: center;&#125;.todos .item text &#123; flex:1; font-size: 30rpx; color: #888; margin-left: 20rpx;&#125; 为了样式美观，我们将最后一个item的下边框去除 123.todos .item:last-child &#123; border-bottom: 0;&#125; 最后设置底部部分，简单采用flex布局，并使布局方式justify-content设置为space-between 至此样式布局完成！！！ 下篇将介绍如何抽象数据模型。","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"TODOS案例（一）","slug":"TODOS案例（一）","date":"2017-11-18T14:38:07.000Z","updated":"2019-04-17T00:30:49.676Z","comments":true,"path":"passages/TODOS案例（一）/","link":"","permalink":"http://yoursite.com/passages/TODOS案例（一）/","excerpt":"","text":"界面结构设计通过对微信小程序的学习，我们简单通过所学的知识设计一个TODOS案例，整个TODOS包括添加事件功能，标记功能，删除事件功能，标记所有功能，剩余事件提醒功能以及清除所有事件功能。 本片微博将分为14篇对本案例过程进行详细介绍。 下面开始第一部分：界面结构设计。 首先在pages中新建todos页面以及内容 在app.json中注册主页面以及导航栏的标题 12345678910111213&#123; \"pages\": [ \"pages/todos/todos\" ], \"window\": &#123; \"backgroundTextStyle\": \"light\", \"navigationBarBackgroundColor\": \"#fff\", \"navigationBarTitleText\": \"TODOS\", \"navigationBarTextStyle\": \"black\" &#125;, \"sitemapLocation\": \"sitemap.json\"&#125; 接下来，我们根据界面图先设计好框架 整个界面可分为上中下三部分： 第一部分包括添加事件按钮，input输入框 第二部分包括事件完成勾选icon，事件展示text，以及事件清除icon 第三部分为底部事件提醒以及功能按钮 12345678910111213141516171819202122232425262728&lt;view class=\"container\"&gt; &lt;view class=\"search\"&gt; &lt;image src=\"../../images/plus.png\" &gt;&lt;/image&gt; &lt;input type='text' placeholder='Anything here ...'&gt;&lt;/input&gt; &lt;/view&gt; &lt;view class=\"todos\"&gt; &lt;view class='item'&gt; &lt;icon type='success'&gt;&lt;/icon&gt; &lt;text&gt;Learning HTML&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class='item'&gt; &lt;icon type='circle'&gt;&lt;/icon&gt; &lt;text&gt;Learning CSS&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt; &lt;/view&gt; &lt;view class='item'&gt; &lt;icon type='success'&gt;&lt;/icon&gt; &lt;text&gt;Learning JS&lt;/text&gt; &lt;icon type='clear'&gt;&lt;/icon&gt;&lt;/view&gt; &lt;/view&gt; &lt;view class=\"footer\"&gt; &lt;text&gt;Toggle ALL&lt;/text&gt; &lt;text&gt;0 item left&lt;/text&gt; &lt;text&gt;Clear&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; 代码中的text文档暂时用文字代表，之后通过事件绑定进行渲染 整个框架搭建完成后如图所示","categories":[],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"伸缩布局","slug":"伸缩布局","date":"2017-11-16T11:21:25.000Z","updated":"2019-04-16T12:43:32.082Z","comments":true,"path":"passages/伸缩布局/","link":"","permalink":"http://yoursite.com/passages/伸缩布局/","excerpt":"","text":"Flex伸缩布局Flexible意为可伸缩的，Box意为盒子，可以理解为一种新式的盒模型——伸缩盒模型。由CSS3规范提出，这是在原有的大家非常熟悉的block, inline-block, inline的基础上延伸出的新一代布局模式。 伸缩的基本概念 1.Flex container即伸缩盒容器，可以理解为将要被分的房子，分之前需要将display属性声明为flex或者inline-flex 2.Flex item即伸缩项可以理解为房子里的居民，他们会占有一定的住房面积，我们先用代码来解释一下 12345&lt;div class=\"container\"&gt; &lt;div class=\"item2\"&gt;&lt;/div&gt; &lt;div class=\"item3\"&gt;&lt;/div&gt; &lt;div class=\"item4\"&gt;&lt;/div&gt; &lt;/div&gt; 样式设置为 1234567891011121314151617181920212223 .container &#123; width: 300px; height: 100px; display: flex; &#125;.item1 &#123; flex: 1; width: 100px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 100px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 1; width: 100px; height: 100px; background-color: red; &#125; 结果如图所示: 可以看到房子被平分成三分！ 但是有人如果想住大点的房子，我们可以直接改变flex的值来实现，例如: 123456789101112131415161718.item1 &#123; flex: 1; width: 100px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 100px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 2; width: 100px; height: 100px; background-color: red; &#125; 3.Axes轴图中分别标注了主轴和次轴，但是事实上那一条是主轴可以由我们自己规定。 flex-direction 此属性规定哪条轴为主轴。 justify-content 此属性设置了伸缩项在主轴方向上的排列方式，这个稍后解释。 align-items 此属性和上面的justify-content相对，表示伸缩项在次轴上的排列方式。 align-self 此属性规定某一个特定的伸缩项元素在次轴上的布局方式，在某个元素上设置该属性会覆盖它的align-items属性。也就是这个属性会让某个元素更有个性，不走寻常路~ 4.flex-direction当我们不想沿着默认的方向分房子的时候，我们可以改变flex-direction属性的值来改变主轴和方向，该属性默认的取值为row； 当取值为row-reverse时，伸缩项逆置： 123456.container &#123; width: 300px; height: 100px; display: flex; flex-direction: row-reverse; &#125; 当此属性设置为column时，主次轴就会对调，元素的排列方向也会随之改变： 123456.container &#123; width: 300px; height: 100px; display: flex; flex-direction: column; &#125; 至于flex: column-reverse的含义和row-reverse类似 5.justify-contents有的时候，大家挨着住，一点空隙都没有也会很难受，连个过道都没有，隐私也不能保证对吧。这个时候，我们可以改变分配政策了，不再按比例分配，而是定额分配，每个人的面积是确定的。多出的房屋面积改成公共区域。 为了更好地看见区别，我们将每一个item宽度缩小 123456789101112131415161718.item1 &#123; flex: 1; width: 80px; height: 100px; background-color: blue; &#125; .item2 &#123; flex: 1; width: 80px; height: 100px; background-color: yellow; &#125; .item3 &#123; flex: 2; width: 80px; height: 100px; background-color: red; &#125; 设定了width属性后也要记得去掉flex属性的声明，不然flex属性的效果仍然会把width覆盖掉同时，如果width属性也不设定的话，元素宽度会表现为内容的宽度，即当伸缩项内部无内容时，将不会进行渲染，其表现就和display: none;一样。 这时，在容器上声明justify-content属性就可以安排伸缩项的位置了： 123.contianer &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 6.align-items这项属性会改变次轴上元素排列的方式，对于本例来说原来次轴方向上元素的高度是表现为height: 100%;的，设定了align-items属性后，其高度表现就会发生改变了。 123.content &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 至于各项的作用，可以动手试试！ 7.order在伸缩项上声明此属性，可以无视HTML结构的顺序而按照order从小到大的顺序沿flex-direction方向排列。比如： 123456789101112131415161718192021.item1 &#123; flex: 1; width: 80px; height: 100px; background-color: blue; order: 3;&#125;.item2 &#123; flex: 1; width: 80px; height: 100px; background-color: yellow; order: 1；&#125;.item3 &#123; flex: 2; width: 80px; height: 100px; background-color: red; order: 2;&#125; 8.flex-wrap此属性的默认值为nowrap，也就是忽略伸缩项的宽度，管你要多少住房面积，通通按照flex属性说好的分配，不许换行。 为了方便观察，我们先将盒子宽度设为150px； 123456789101112131415.item1 &#123; width: 150px; height: 100px; background-color: blue; order: 3; &#125; .container &#123; width: 300px; height: 100px; display: flex; flex-direction: row; flex-wrap: nowrap;//wrap &#125; 9.flex-grow，flex-shrink 和 flex-basis上文提到的flex属性实际上是这三个属性的简写形式。这三个属性有相似性，都是表示项与项之间分配空间的相对比例关系，不同之处在于： flex-grow属性：属性值为该伸缩项所占空间相对于其他伸缩项（声明了flex相关属性的项）的比值。 flex-shrink属性：该伸缩项相对于其他伸缩项缩小的比值，也就是说当flex-shrink: 3;时，该项所占空间为其他项的1/3。flex-basis属性：属性值为该项所占空间占容器空间的百分比。 注意：对于flex-basis属性，当所有项的属性值相加&lt;=100%时，会严格按照百分比值来渲染。当属性值相加&gt;100%时，元素并不会溢出，而是表现为两两之间所占空间大小遵循相互的百分比比值。也就是说当存在三个伸缩项且flex-basis值都为50%时，表现行为与三个项均为flex: 1;一样。 Flexible Boxes布局模式在响应式开发中尤其好用，对不同的终端，设置元素之间的空间分配关系将会变成一件非常简单的事。后期微信小程序中也是十分好用，伸缩盒布局和响应式布局中流行的流体布局哪种更好，还是可以结合起来，就看各位开发者发挥自己的聪明才智了！","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"JS学习总结（三）","slug":"JS学习总结（三）","date":"2017-10-11T13:06:48.000Z","updated":"2019-04-07T07:32:11.262Z","comments":true,"path":"passages/JS学习总结（三）/","link":"","permalink":"http://yoursite.com/passages/JS学习总结（三）/","excerpt":"","text":"一，script标签书写位置js的代码可以分三个地方写: 1.在html的文件中,script的标签中写js代码2.js代码可以在html的标签中写—3.在js文件中可以写js代码,但是需要在html的页面中引入 script的标签中的src=”js的路径” 二，js代码的注意问题 1.在一对script的标签中有错误的js代码,那么该错误的代码后面的js代码不会执行2.如果第一对的script标签中有错误,不会影响后面的script标签中的js代码执行3.script的标签中可以写什么内容 type=”text/javascript”是标准写法或者写language=”JavaScript”都可以但是,目前在我们的html页面中,type和language都可以省略,原因:html是遵循h5的标准4.有可能会出现这种情况:script标签中可能同时出现type和language的写法.5.script标签在页面中可以出现多对6.script标签一般是放在body的标签的最后的,有的时候会在head标签中,目前讲课的时候都在body标签的后面(body中的最后)7.如果script标签是引入外部js文件的作用,那么这对标签中不要写任何的js代码,如果要写,重新写一对script标签,里面写代码 三，变量 变量:========&gt; 操作的数据都是在内存中操作 js中存储数据使用变量的方式(名字,值—&gt;数据) js中声明变量都用var—-&gt;存储数据,数据应该有对应的数据类型 js中的字符串类型的值都用双引号或者单引号 存储一个数字10 变量的声明及赋值 var num=10; 存储一个名字 var name=&#39;小黑&#39;; 变量—作用,存储数据的或者是操作数据 变量声明(有var 有变量名字,没有值) 变量初始化(有var 有变量名字,有值) 变量声明的方式: 123456789101112131415 //一次性声明多个变量 var x,y,z,k,j;//都是声明,没有赋值//变量的初始化(变量声明的同时并且赋值了)// = 的意义:赋值的含义var number = 10;//存储一个5var number2 = 5;//存储一个人的名字var name = \"小黑\";//存储真(true)var flag = true;//存储一个null---&gt;相当于是var obj = new Object();// var 变量名字; 四，变量总结 变量作用:用来操作数据的(可以存储,可以读取) 变量的声明:没有赋值 var 变量名; 变量的初始化:有赋值 var 变量名=值; 注意的基本的代码的规范 js中声明变量都用var js中的每一行代码结束都应该有分号;(写代码有分号的习惯) js中的大小写是区分的: var N=10; n js中的字符串可以使用单引号,也可以使用双引号,目前我们暂时使用双引号 变量名的注意问题—变量名的命名规范,要遵循驼峰命名法 1.变量的名字要有意义, 2.变量名有一定的规范:一般以字母,$符号,下划线开头,中间或者后面可以有$符号,字母,数字 3.变量名一般都是小写的 4.变量名如果是多个单词,第一个单词的首字母是小写的,后面的所有的单词的首字母都是大写的,这种命名方式称为:驼峰命名法 5.不能使用关键字(系统自带的一些单词,不能使用) 6.不会单词用拼音,拼音也要遵循驼峰命名法 var bigNumber=10; 声明变量并初始化—变量的初始化—-声明变量赋值 声明多个变量然后一个一个的赋值 声明多个变量并且赋值 123456789101112131415var num=100;//输出这个变量的值alert(num);//弹框//浏览器的控制台在浏览器中的开发人员工具中(快捷键:F12)的console的选项中console.log(num);//把内容输出在浏览器的控制台中// //依次的赋值num1=10;num2=20;num3=30;var num1=10,num2=20,num3=30;var num=10;var $break=10;var shuZi=10; 五，数字交换的三种方式变量的交换的第一个思路:使用第三方的变量进行交换123456789var num2=20;// //把num1这个变量的值取出来放在temp变量中var temp=num1;// //把num2这个变量的值取出来放在num1变量中num1=num2;// //把temp变量的值取出来放在num2变量中num2=temp;console.log(num1);//20console.log(num2);//10 第二种方式交换:一般适用于数字的交换 12345678var num2 = 20;// //把num1的变量中的值和num2变量中的值,取出来相加,重新赋值给num1这个变量num1 = num1 + num2;//30// //num1变量的值和num2变量的值取出来,相减的结果重新赋值给num2num2 = num1 - num2;//10// //num1变量的值和num2变量的值取出来,相减的结果重新赋值给num1num1 = num1 - num2;//20console.log(num1, num2); Ctrl+Alt+L—–&gt;格式化代码的(设置代码有很好的格式,代码是错误的,这个快捷键是没有效果) 注意；变量的名字是不能重名 123var num1=10;var num1=20;console.log(num1); 扩展的变量的交换:只需要看代码,不需要理解—位运算12345var num2 = 20;num1 = num1 ^ num2;num2 = num1 ^ num2;num1 = num1 ^ num2;console.log(num1, num2); 六，数据类型声明变量并初始化var num=10;js中的数据类型有哪些?js中的原始数据类型:number,string,boolean,null,undefined,object number:数字类型(整数和小数) string:字符串类型(的值一般都是用单引号或者是双引号括起来) “34” boolean:布尔类型(值只有两个,true(真1),false(假0)) null:空类型,值只有一个:null,一个对象指向为空了,此时可以赋值为null undefined:未定义,值只有一个:undefined 什么情况下的结果是undefined 变量声明了,没有赋值,结果是undefined 函数没有明确返回值,如果接收了,结果也是undefined 如果一个变量的结果是undefined和一个数字进行计算,结果:NaN不是一个数字,也没有意义 object:对象—-&gt; 1234var num; var num;console.log(num+10);//NaN-----not an number----&gt;不是一个数字`var num;console.log(num);` 如何获取这个变量的数据类型是什么? 使用typeof 来获取typeof 的使用的语法 都可以获取这个变量的数据类型是什么! typeof 变量名 typeof(变量名) 12345678910111213141516var str = \"小白\";var flag = true;var nll = null;var undef;var obj = new Object();//是使用typeof 获取变量的类型console.log(typeof num);//numberconsole.log(typeof str);//stringconsole.log(typeof flag);//booleanconsole.log(String(nll));//是nullconsole.log(typeof nll);//不是nullconsole.log(typeof undef);//undefinedconsole.log(typeof obj);//objectconsole.log(typeof(num));// console.log(\"10\");// console.log(10); 七，数字类型 数字类型:number类型 无论是整数还是小数都是数字类型 不要用小数验证小数 不要使用NaN判断是不是NaN，应该使用isNaN(值或者是变量) 想要表示十进制:就是正常的数字 想要表示八进制:以0开头 想要表示十六进制:0x开头 八，字符串类型12var str=\"10\";//字符串var str2='20';//字符串 字符串可以使用单引号,也可以使用双引号 字符串的长度如何获取? 变量名.length 123456var str=\"what are you no sha lei\";// //字符串的个数有多少个?这个字符串的长度是多少console.log(str.length);//var str1=\"fdshfjworwoijpfskj;akjfpojfiwnmoiwajdoiwajiwaewowj\";console.log(str1.length); html中的转义符: &lt; &lt; &gt; &gt; 空格: &nbsp;js中的字符串里也有转义符 tab键—-水平制表符 123console.log(\"哈哈\\t嘎嘎\");console.log(\"哈哈\\\"嘎嘎\");console.log('哈哈\\'嘎嘎');` 字符串的拼接: 使用+可以把多个字符串放在一起形成一个字符串只要有一个是字符串,其他的是数字,那么结果也是拼接,不是相加如果有一个是字符串,另一个不是字符串,使用- 号,此时会发生计算 1234567891011121314151617181920var str1=\"您好\";var str2=\"我好\";console.log(str1+str2);console.log(\"哈哈\"+\"嘎嘎\"+\"嘿嘿\");var str1=\"10\";var str2=\"20\";console.log(str1+str2);var str1=\"10\";var str2=20;console.log(str1+str2);var str1 = \"10\";var str2 = 5;// //浏览器帮助我们自动的把字符串类型转成了数字类型,这种方式叫:隐式转换console.log(str1-str2);var str1=\"10\";var str2=5;console.log(str1*str2); 九，布尔类型布尔类型:的值有两个,一个是true(真),一个是false(假) 123456var flag=1;console.log(flag);var fdf=null;//var num=0; 十，类型转换其他类型转数字类型:三种方式: 1.parseInt();//转整数 123456console.log(parseInt(\"10\"));//10console.log(parseInt(\"10afrswfdsf\"));//10console.log(parseInt(\"g10\"));//NaNconsole.log(parseInt(\"1fds0\"));//1console.log(parseInt(\"10.98\"));//10console.log(parseInt(\"10.98fdsfd\"));//10 2.parseFloat()//转小数 123456console.log(parseFloat(\"10\"));//10console.log(parseFloat(\"10afrswfdsf\"));//10console.log(parseFloat(\"g10\"));//NaNconsole.log(parseFloat(\"1fds0\"));//1console.log(parseFloat(\"10.98\"));//10.98console.log(parseFloat(\"10.98fdsfd\"));//10.98 3.Number();//转数字 123456console.log(Number(\"10\"));//10console.log(Number(\"10afrswfdsf\"));//NaNconsole.log(Number(\"g10\"));//NaNconsole.log(Number(\"1fds0\"));//NaNconsole.log(Number(\"10.98\"));//10.98console.log(Number(\"10.98fdsfd\"));//NaN 总结:想要转整数用parseInt(),想要转小数用parseFloat()想要转数字:Number();要比上面的两种方式严格 其他类型转字符串类型 1.toString() 12var num=10;console.log(num.toString());//字符串类型 String() 12var num1=20;console.log(String(num1)); 如果变量有意义调用.toString()使用转换 如果变量没有意义使用String()转换 12345678910var num2;console.log(num2.toString());var num3=null;console.log(num3.toString()); //这个可以var num2;console.log(String(num2));var num3=null;console.log(String(num3)); 其他类型转布尔类型 Boolean(值); 12345678910111213//console.log(Boolean(1));//trueconsole.log(Boolean(0));//falseconsole.log(Boolean(11));//trueconsole.log(Boolean(-10));//trueconsole.log(Boolean(\"哈哈\"));//trueconsole.log(Boolean(\"\"));//falseconsole.log(Boolean(null));//falseconsole.log(Boolean(undefined));//falsevar str=10;console.log(+str); 十一，操作符 操作符:一些符号—–用来计算 算数运算符: + - * / % 算数运算表达式:由算数运算符连接起来的表达式 一元运算符: 这个操作符只需要一个操作数就可以运算的符号 ++ – 二元运算符: 这个操作符需要两个操作数就可以运算, 三元运算符: —–不讲,明天讲 复合运算符: += -= *= /= %= 复合运算表达式:由复合运算符连接起来的表达式 var num=10; num+=10;------&gt;就是:num=num+10; console.log(num);20 关系运算符: &gt; &lt; &gt;= &lt;= ==不严格的 ===严格的 !=不严格的不等 !==严格的不等 关系运算表达式:由关系运算符连接起来的表达式 关系运算表达式的结果是布尔类型 逻辑运算符: &amp;&amp;—逻辑与–并且 ||—逻辑或—或者 !—逻辑非—取反–取非 逻辑运算表达式:由逻辑运算符连接起来的表达式 表达式1&amp;&amp;表达式2 如果有一个为false,整个的结果就是false 表达式1||表达式2 如果有一个为true,整个的结果为true !表达式1 表达式1的结果是true,整个结果为false 表达式1的结果是false,整个结果为true 赋值运算符: = 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var num1=10;var num2=20; //console.log(num1==num2&amp;&amp;5&gt;6); var num=20;console.log(num&gt;10||5&lt;0);var flag=false;console.log(!flag);var num=10;var sum=(num+10)*5;console.log(sum);var result = (4 &gt;= 6 || '人' != '狗' &amp;&amp; !(12 * 2 == 144) &amp;&amp; true);console.log(result);//var num = 10;//var result2 =( 5 == num / 2 &amp;&amp; (2 + 2 * num).toString() === '22');console.log(result2);var num=20;var result=num/3;//num变量与3取余---&gt;10/3的余数console.log(parseInt(result));var num=20;var result=num%3;//num变量与3取余---&gt;10/3的余数console.log(result);var num=10;var sum=(num+10)+10;var num = 20;num %= 5; // // num=num-5;console.log(num);var str=\"5\";var num=5;console.log(str===num);console.log(5&gt;10);//falseconsole.log(5&gt;=5);//trueconsole.log(5&gt;3);//trueconsole.log(5==10);//false 字面量: 把一个值直接赋值给一个变量 声明变量并初始化 12345678var num=10;//var flag=true;//var str=\"哈哈哈\";//var y=10;var n=y;","categories":[],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"html学习总结（一）","slug":"html学习总结（一）","date":"2017-10-03T06:39:18.000Z","updated":"2019-04-07T06:45:20.380Z","comments":true,"path":"passages/html学习总结（一）/","link":"","permalink":"http://yoursite.com/passages/html学习总结（一）/","excerpt":"","text":"一，浏览器内核1.浏览器内核可分为渲染引擎和js引擎： 渲染引擎:它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。 JS 引擎:则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。 2.常见浏览器分类（1） Trident（IE内核） （2）Gecko（火狐） （3）Webkit（Safari） （4）Chromium（Chrome） （5）Presto 3.Web标准的构成主要包括结构，样式和行为三个方面 结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。 最重要表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript 4.Html语法骨架1234567&lt;HTML&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/HTML&gt; HTML标签： 作用所有HTML中标签的一个根节点。 最大的标签 根标签 head标签： 文档的头部 文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。 注意在head标签中我们必须要设置的标签是title title标签： 文档的标题 作用：让页面拥有一个属于自己的标题。 body标签：文档的主体 以后我们的页面内容 基本都是放到body里面的 body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。） 5.HTML标签分类（1）双标签 1&lt;标签名&gt;内容&lt;/标签名&gt; （2）单标签 1&lt;标签名&gt; 6.HTML标签关系（1）嵌套关系 123&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt; （2）并列关系 12345&lt;head&gt; &lt;body&gt; &lt;/body&gt;&lt;/head&gt; 7.文档类型&lt;!DOCTYPE&gt;1&lt;!DOCTYPE html&gt; &lt;!DOCTYPE&gt; 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用&lt;!DOCTYPE&gt;标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。 8.字符集utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。 gb2312 简单中文 包括6763个汉字 BIG5 繁体中文 港澳台等用 GBK包含全部中文字符 是GB2312的扩展，加入对繁体字的支持，兼容GB2312 UTF-8则包含全世界所有国家需要用到的字符 9.HTML常用标签标题标签1&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;和&lt;h6&gt; 标题标签语义： 作为标题使用，并且依据重要性递减 基本语法格式 1&lt;hn&gt; 标题文本 &lt;/hn&gt; 段落标签1&lt;p&gt; 文本内容 &lt;/p&gt; 标签语义：文章分段 水平线标签1&lt;hr&gt; 标签语义：将段落与段落之间隔开，使得文档结构清晰，层次分明 换行标签1&lt;br&gt; 文本格式化标签1234&lt;strong&gt;加粗&lt;/strong&gt;&lt;em&gt;斜体&lt;/em&gt;&lt;del&gt;删除线&lt;/del&gt;&lt;u&gt;下划线&lt;/u&gt; 10.图像标签1&lt;img src=\"图像URL\" /&gt; 标签属性：12345678&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" …&gt; 内容 &lt;/标签名&gt;在上面的语法中：1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。3.任何标签的属性都有默认值，省略该属性则取默认值。采取 键值对 的格式 key=\"value\" 的格式 img属性1234567属性 属性值 描述src URL 路径alt 文本 不能显示时替换的文本title 文本 鼠标悬停的内容width px 宽度height px 高度border 数字 图像边框宽度 11.链接标签12345&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;文本或图像&lt;/a&gt;href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。 Hypertext Reference的缩写。意思是超文本引用target：用于指定链接页面的打开方式，其取值有self和blank两种，其中self为默认值，blank为在新窗口中打开方式 1.外部链接 需要添加 http:// www.baidu.com 2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=”index.html”&gt; 首页 3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=”#”)，表示该链接暂时为一个空链接。 4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。 12.base标签123&lt;head&gt; &lt;base target=\"blank/self\"&gt;&lt;/head&gt; 标签语义：设置链接打开方式窗口是新建还是覆盖 13.锚点定位通过创建锚点，快速定位到目标内容 123451.使用“a href=”#id名&gt;“链接文本\"&lt;/a&gt;创建链接文本（被点击的） &lt;a href=\"#two\"&gt; 2.使用相应的id名标注跳转目标的位置。 &lt;h3 id=\"two\"&gt;第2集&lt;/h3&gt; 14.注释标签1&lt;!--注释语句--&gt; Ctrl+/ 注释的两个作用： 1.让部分代码不让浏览器执行 2.给程序员友好的提示 15.列表标签无序列表123456&lt;ul&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ul&gt; 中只能嵌套，直接在标签中输入其他标签或者文字的做法是不被允许的。 与之间相当于一个容器，可以容纳所有元素。 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！ 有序列表123456&lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; &lt;li&gt;列表项3&lt;/li&gt; ......&lt;/ol&gt; 自定义列表12345678910&lt;dl&gt; &lt;dt&gt;名词1&lt;/dt&gt; &lt;dd&gt;名词1解释1&lt;/dd&gt; &lt;dd&gt;名词1解释2&lt;/dd&gt; ... &lt;dt&gt;名词2&lt;/dt&gt; &lt;dd&gt;名词2解释1&lt;/dd&gt; &lt;dd&gt;名词2解释2&lt;/dd&gt; ...&lt;/dl&gt; 定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。 16.表格创建表格1234567&lt;table&gt; &lt;tr&gt; &lt;td&gt;单元格内的文字&lt;/td&gt; ... &lt;/tr&gt; ...&lt;/table&gt; 1.table用于定义一个表格。 2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。 3.td /td：用于定义表格中的单元格，必须嵌套在标签中，一对 中包含几对，就表示该行中有多少列（或多少个单元格）。 注意： 中只能嵌套 标签，他就像一个容器，可以容纳所有的元素 表格属性border：设置表格边框的宽度（默认border=’0’） cellspacing：单元格与单元格之间的空白间距 cellspadding：单元格内容与边框之间的空白间距 width：表格宽度 height：表格高度 align：表格在网页中的水平对齐方式（left,right,center） 表头标签表头一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。 表格结构 在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示： ：用于定义表格的头部。 必须位于 标签中，一般包含网页的logo和导航等头部信息。 ：用于定义表格的主体。 位于标签中，一般包含网页中除头部和底部之外的其他内容。 表格标题caption 123&lt;table&gt; &lt;caption&gt;我是表格标题&lt;/caption&gt;&lt;/table&gt; 合并表格跨行合并：rowspan（跨多少行删多少行） 跨列合并：colspan（跨多少行删多少行） 17.div span标签 div在浏览器中表示一个小区域，不会增加任何的效果改变，而是语义变了，div中所有子元素是在一个小区域中。div是一个容器，里面什么都能放，设置包括它自己 。 span也是表示一个小区域，但是只能是文本级别的区域，也就是span中只能够放文字、图片、表单元素等信息。 现在的网页开发基本都是用div+css布局实现的。 div和span的使用123456789101112131415161718192021222324&lt;div&gt; &lt;h3&gt;中国主要城市&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;北京&lt;/li&gt; &lt;li&gt;深圳&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;div&gt; &lt;h3&gt;美国主要城市&lt;/h3&gt;&lt;ul&gt; &lt;li&gt;伦敦&lt;/li&gt; &lt;li&gt;纽约&lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;&lt;p&gt; 商品简介，商品简介 &lt;span&gt; &lt;a href=””&gt;详细信息&lt;/a&gt; &lt;a href=””&gt;购买&lt;/a&gt;&lt;/span&gt;&lt;/p&gt; 18.内联元素和块级元素 div标签（独占一行 block） （div,form,table,p,pre,h1~h6,dl,ol,ul）特点：块级元素独占一行，可以设置宽度和高度。如果不设置宽度，则默认宽度为父元素的宽度。 span标签（占一块 inline）(span,a,label ,select)特点：所有元素在一行显示。不能设置宽高。默认宽度为文字或者内容本身的宽度。 行内块元素（inline-block） (image input)特点：所有元素在一行显示，可以设置宽高(具备块级元素的特征，也具备行内元素的特征)。 19.表单标签 包括表单控件，提示信息，表单域 表单控件： 包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。 提示信息： 一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。 表单域： 他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。 表单域在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下： 123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt; 各种表单控件&lt;/form&gt; 常用属性： Action在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。 method用于设置表单数据的提交方式，其取值为get或post。 name绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。 用于指定表单的名称，以区分同一个页面中的多个表单。 注意： 每个表单都应该有自己表单域。 input控件text属性 &lt;input type=”text”&gt; 定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。 其它常用属性: l name:定义标签名称 l value:定义标签值 l size:定义输入字符的长度（可以输入超过指定长度的字符，但只会显示指定个数） l maxlength:定义可输入最大字符个数 l placeholder: 占位文字 password &lt;input type=”password”&gt; 定义密码字段。该字段中的字符被掩码. 其它常用属性: l name:定义标签名称 l value:定义标签值 l size:定义输入字段的长度 l maxlength:定义可输入最大字符个数 radio &lt;input type=”radio”&gt; 定义单选按钮。 其它常用属性: l name:定义标签名称.注意，对于单选按钮，如果要想做到单一选择，多个radion的name值必一样。 l value:定义标签值 l checked:定义该标签默认被选中。 checkbox &lt;input type=”checkbox”&gt; 定义复选框。 其它常用属性: l name:定义标签名称.注意，一组的checkbox它们的name值应该是一样的。 l value:定义标签值 l checked:定义该标签默认被选中。 file &lt;input type=”file”&gt; 定义输入字段和 “浏览”按钮，供文件上传。 其它常用属性: l name:定义标签名称 button &lt;input type=”button”&gt; 定义可点击按钮（多数情况下，用于通过JavaScript 启动脚本，如果不写什么也不发生） 其它常用属性: l name:定义标签名称 l value:按钮显示名称 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 其它常用属性: l name:定义标签名称 l value:按钮显示名称 reset 定义重置按钮。重置按钮会清除表单中的所有数据。 其它常用属性: l name:定义标签名称 l value:按钮显示名称 img 定义图像形式的提交按钮。 这个标签主要是用了替换submit按钮，因为默认产生的提交按钮并不漂亮，这个标签允许你采用指定的图片做为提交按钮。 其它常用属性: l name:定义标签名称 l src:定义作为提交按钮显示的图像的url l alt:定义作用图像的替代文本。 绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。hidden &lt;inputtype=”hidden”&gt; 定义隐藏的输入字段。提交时服务端需要用到的信息，但是又不想让用户看到 常用属性: l name: 定义标签名称 l value:定义标签值 20.label标签label 标签为 input 元素定义标注（标签）。 作用： 用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点 如何绑定元素呢？ for 属性规定 label 与哪个表单元素绑定。 12&lt;label for=\"male\"&gt;Male&lt;/label&gt;&lt;input type=\"radio\" name=\"sex\" id=\"male\" value=\"male\"&gt; 21.textarea控件如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下： 123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt; 文本内容&lt;/textarea&gt; 22.下拉菜单123456&lt;select name=\"select\" multiple=\"multiple\" size=\"6\"&gt; &lt;option value=\"wx\" selected=\"selected\"&gt;无锡&lt;/option&gt; &lt;option value=\"wz\" selected=\"selected\"&gt;苏州&lt;/option&gt; &lt;option value=\"sh\" selected=\"selected\"&gt;上海&lt;/option&gt; &lt;option value=\"ks\" selected=\"selected\"&gt;昆山&lt;/option&gt;&lt;/select&gt; 注意： &lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。 在option 中定义selected =” selected “时，当前项即为默认选中项。 23.其他标签上标下标1234567&lt;p&gt;This text contains &lt;sub&gt;subscript&lt;/sub&gt;&lt;/p&gt;&lt;p&gt;This text contains &lt;sup&gt;superscript&lt;/sup&gt;&lt;/p&gt; pre标签（照原样输出）123456&lt;pre&gt; 这是 预格式文本。 它保留了 空格 和换行。&lt;/pre&gt; iframeiframe 元素会创建包含另外一个文档的内联框架（即行内框架）。可以理解为浏览器中的浏览器 1iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。可以理解为浏览器中的浏览器 24.路径相对路径以引用文件之网页所在位置为参考基础，而建立出的目录路径。因此，当保存于不同目录的网页引用同一个文件时，所使用的路径将不相同，故称之为相对路径。 图像文件和HTML文件位于同一文件夹：只需输入图像文件的名称即可，如&lt;img src=”logo.gif” /&gt;。 图像文件位于HTML文件的下一级文件夹：输入文件夹名和文件名，之间用“/”隔开，如&lt;img src=”img/img01/logo.gif” /&gt;。 图像文件位于HTML文件的上一级文件夹：在文件名之前加入“../” ，如果是上两级，则需要使用 “../ ../”，以此类推，如&lt;img src=”../logo.gif” /&gt;。 绝对路径绝对路径以Web站点根目录为参考基础的目录路径。之所以称为绝对，意指当所有网页引用同一个文件时，所使用的路径都是一样的 “D:\\web\\img\\logo.gif”，或完整的网络地址，例如“http://www.igeek.cn/images/logo.gif”。","categories":[],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Hexo博客搭建完整流程","slug":"Hexo博客搭建完整流程","date":"2017-10-03T02:59:27.000Z","updated":"2019-04-01T09:20:26.606Z","comments":true,"path":"passages/Hexo博客搭建完整流程/","link":"","permalink":"http://yoursite.com/passages/Hexo博客搭建完整流程/","excerpt":"","text":"一，准备工作1.了解HexoHexo是高效的静态站点生成框架，它基于Node.js。 通过 Hexo 你可以使用Markdown 编写文章。 2.搭建Node.js环境搭建博客网站首先需要安装Node.js环境。 下载地址：http://nodejs.cn/download 测试安装：命令行使用node -v 、npm -v，查看显示版本号即成功。 Ps:大部分同学装的node版本是之前提供的5.0.0多的 hexo的初始化步骤中会出现报错，需要重新装最新的版本（10.0.0多的） 3.安装Hexo博客框架工具Hexo是一个建站工具，可以帮助我们快速生成基本的博客文件，安装它需要在控制台下（Windows+R+cmd）使用如下命令： npm install hexo-cli -g 4.安装Git版本工具Git是目前世界上最流行的分布式版本控制系统 使用Git可以帮助我们把本地的网页和文章等内容提交到Github上，实现同步。 下载地址：https://git-scm.com/downloads 测试安装:右击鼠标，如果有 Git GUI here Git Bash here 两个选项 即安装成功。 5.注册Github账号gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。这里用到Github，是因为我们需要通过Github得到自己的博客网站域名，而且需要使用gitHub同步我们个人博客的相关文件。 注册地址：https://github.com 二，开始搭建博客1.开启Github服务通过Github Pages获得一个免费使用的域名，这需要我们在Github上新建一个仓库，如下： 注意：新仓库的名字，最好是 UserName+“github.io”` 的形式。这也是之前强调的要起一个好的用户名的原因。这样之后我们最后的博客网站的链接就会是：https://UserName.github.io的形式。 点击Create Repository之后，随后选择Setting进入设置，找到Github Pages如下： 这里我们需要点击Choose a theme任意选择一个选择主题，然后界面会跳转到仓库，我们看到有两个文件如下： 再查看setting，我们会看到开启GitHub Pages之后得到的域名如下： 现在，可以使用 https://UserName.github.io 访问自己的博客网站了，打开链接我们会看到默认主题的个人博客样式如下(虽然点丑)： 2.创建本地博客站点上述的步骤相当于我们使用Github，创建了一个默认的博客页，并且得到了一个可外部访问的域名。但是这个博客页很丑。我们的目的是创建自己个性化的博客网站，所以我们使用Hexo在本地先创建一个本地博客站点，优化后再把它部署到github上。接下来我们使用控制台(Windows+R+cmd)命令在本地一个合适的位置右键git bash here 输入hexo init blog 创建博客站点文件夹如下： 测试本地博客站点，进入blog文件夹（此即为本地博客根目录）右键git bash here： 12hexo g //g是generetor的缩写，生成博客 hexo s //s是server的缩写，启动本地服务 此时打开浏览器，输入 http://localhost:4000/，我们将会看到Hexo自带默认主题显示的博客样式如下: 3.同步Github，允许公共访问 初次安装git需要配置用户名和邮箱，否则git会提示： please tell me who you are. 你需要运行命令来配置你的用户名和邮箱： 12$ git config --global user.name &quot;name&quot;$ git config --global user.email &quot;email&quot; 注意：（引号内请输入你自己设置的名字，和你自己的邮箱）此用户名和邮箱是git提交代码时用来显示你身份和联系方式的，并不是github用户名和邮箱 4.Git配置ssh key在博客站点右键Git bash here 输入$ ssh-keygen -t rsa -C &quot;youremail&quot; 第一次生成的话，直接一路回车，不需要输入密码。不是第一次生成的话，会提示 overwrite (y/n)? 问你是否覆盖旧的 SSH Key ，直接填 y ，然后一直回车就行了，最后得到了两个文件： id_rsa和id_rsa.pub。 记事本打开/C/Users/Administrator/.ssh/id_rsa.pub文件 复制该段信息；登录github账户，点击头像进入 Settings -&gt; SSH and GPG keys -&gt; New SSH key 将复制的信息粘贴到该处。 测试是否成功 $ssh -T git@github.com 提示 Hi xxx! You&#39;ve successfully authenticated, but GitHub does not provide shell access. 说明添加成功。 5.部署博客在本地我们已经搭建了博客，但是还只能自己本地访问。若要别人也能看到，那就需要我们将其同步部署到GitHub上了。首先找到我们的博客仓库，并拷贝仓库地址： 注意：只需复制用户名之后字段 然后修改本地博客目录的配置：修改本次博客根目录下的_config.yml文件，修改deploy下的配置如下： 注意空格和单词不可以打错 之后执行Git bash here命令： 12npm install hexo-deployer-git //安装部署插件hexo d //部署到github 再次访问链接：https://userName.github.io，就会发现这里的界面和本地的一样了。如此一来我们搭建的个人博客网站就基本完成了。 三，发布博客1.发布可以发布自己的第一篇博客了。来尝试一下以下的步骤：在本地博客文件夹根目录(git bash here)输入： 123hexo new &quot;我个人博客的第一篇博客&quot; hexo g //生成网页 hexo d //部署到远端(github) 生成的博客md文件会存放在blog\\source\\_posts文件夹内。 现在打开我们的博客网站： http://UserName.github.io 会看到网页 （显示可能有延迟 所以可以采用以下方法(git bash)： hexo clean //清理缓存 hexo g //重新生成博客代码 hexo d //部署到服务器 可以用hexo s先查看本地情况再部署到服务器 2.Markdown写作语法推荐使用Typora 1234567891011121314151617181920212223242526272829303132333435363738394041# 写作介绍## 1，字体介绍*这是斜体* 或 _这也是斜体_ **这是粗体*****这是加粗斜体***~~这是删除线~~## 2，分级标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题## 3，超链接写法：## 4,列表无序列表：写法：* 无序列表项1+ 无序列表项2- 无序列表项3有序列表：写法：1.有序列表项12.有序列表项23.有序列表项3## 5，插入图片在 Hexo 中插入图片，首先需要将图片放在 source/img/ 文件夹下，然后如下方式进行插入：![](url)## 6，表格| 表头1|表头2|表头3|表头4|-| :- | :-: | -: ||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐||默认左对齐|左对齐|居中对其|右对齐| 四，更换主题为了让它看起来更美观一些，我们可以为其更换主题（当然也可以自己在默认主题下自己编写美化博客界面）。这里以使用github上的next主题为例 1.下载主题切换到本地博客根目录下(git bash here)输入 1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 下载成之后我们会看到next的主题已经存在thems里了如下： 2.修改博客配置文件，更换主题配置修改博客根目录(不是next主题)下的_config.yml文件，搜索theme字段，并将其值修改为next 然后在控制台（git bash）下输入如下命令 123hexo clean //清理缓存hexo g //重新生成博客代码 hexo d //部署到服务器 再次打开我们的博客网站https://UserName.github.io，将会看到更换的主题 主题美化后续更新……","categories":[],"tags":[{"name":"Hexo搭建微博","slug":"Hexo搭建微博","permalink":"http://yoursite.com/tags/Hexo搭建微博/"}]}]}